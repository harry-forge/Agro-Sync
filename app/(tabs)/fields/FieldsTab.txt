// app/(tabs)/fields/refine/[id].jsx - DEBUG VERSION
import { useState, useEffect } from "react";
import {
    ScrollView,
    StyleSheet,
    Text,
    View,
    Pressable,
    TextInput,
    ActivityIndicator,
} from "react-native";
import { useLocalSearchParams, useRouter } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import ScreenWrapper from "../../../../components/ScreenWrapper";
import BackButton from "../../../../components/BackButton";
import { theme } from "../../../../constants/theme";
import { hp, wp } from "../../../../helpers/common";
import { useFieldData } from "../../../../contexts/FieldContext";
import { getRefinedRecommendation } from "../../../../services/geminiService";

export default function RefineRecommendation() {
    const { id } = useLocalSearchParams();
    const router = useRouter();
    const { fieldData, setFieldData } = useFieldData();

    // Form state
    const [farmSize, setFarmSize] = useState("");
    const [budget, setBudget] = useState("");
    const [laborAvailability, setLaborAvailability] = useState("moderate");
    const [waterSource, setWaterSource] = useState("rainwater");
    const [irrigationSystem, setIrrigationSystem] = useState("none");
    const [marketDistance, setMarketDistance] = useState("");
    const [farmingExperience, setFarmingExperience] = useState("intermediate");
    const [previousCrop, setPreviousCrop] = useState("");
    const [soilTexture, setSoilTexture] = useState("loamy");
    const [organicPreference, setOrganicPreference] = useState("mixed");

    const [loading, setLoading] = useState(false);
    const [error, setError] = useState("");

    const handleGetRefinedRecommendation = async () => {
        if (!farmSize || !budget || !marketDistance) {
            setError("Please fill in all required fields (Farm Size, Budget, Market Distance)");
            return;
        }

        try {
            setLoading(true);
            setError("");

            console.log("üìù Sending refinement data...");
            console.log("Field Data:", {
                temperature: fieldData.temperature,
                humidity: fieldData.humidity,
                moisture: fieldData.moisture,
                N: fieldData.N,
                P: fieldData.P,
                K: fieldData.K,
                pH: fieldData.pH,
            });

            const refinementData = {
                // Original field data
                temperature: fieldData.temperature || 25,
                humidity: fieldData.humidity || 65,
                moisture: fieldData.moisture || 50,
                rainfall: fieldData.rainfall || 800,
                N: fieldData.N || 80,
                P: fieldData.P || 40,
                K: fieldData.K || 40,
                pH: fieldData.pH || 6.5,
                currentRecommendation: fieldData.recommendation?.best_crop || "Rice",

                // User-provided refinement data
                farmSize: parseFloat(farmSize),
                budget: parseFloat(budget),
                laborAvailability,
                waterSource,
                irrigationSystem,
                marketDistance: parseFloat(marketDistance),
                farmingExperience,
                previousCrop: previousCrop || "none",
                soilTexture,
                organicPreference,
            };

            console.log("üì§ Refinement payload:", refinementData);

            const refinedData = await getRefinedRecommendation(refinementData);

            console.log("‚úÖ Received refined data:", refinedData);

            // Store refined data in context
            setFieldData({
                ...fieldData,
                refinedRecommendation: refinedData,
            });

            console.log("üíæ Stored in context, navigating back...");

            // Navigate back to field details
            router.back();
        } catch (e) {
            console.error("‚ùå Refinement error:", e);
            console.error("‚ùå Error stack:", e.stack);
            setError(e.message || "Failed to get refined recommendation. Please try again.");
        } finally {
            setLoading(false);
        }
    };

    return (
        <ScreenWrapper bg="white">
            <View style={styles.header}>
                <BackButton router={router} />
                <Text style={styles.pageTitle}>Refine Recommendation</Text>
                <View style={{ width: 40 }} />
            </View>

            <ScrollView contentContainerStyle={styles.container}>
                <Text style={styles.sectionDesc}>
                    Help us understand your farming conditions better for a more personalized recommendation.
                </Text>

                {/* Farm Size & Budget */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Farm Details</Text>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Farm Size (acres) *</Text>
                        <TextInput
                            style={styles.input}
                            placeholder="e.g., 5"
                            value={farmSize}
                            onChangeText={setFarmSize}
                            keyboardType="decimal-pad"
                        />
                    </View>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Budget (‚Çπ) *</Text>
                        <TextInput
                            style={styles.input}
                            placeholder="e.g., 50000"
                            value={budget}
                            onChangeText={setBudget}
                            keyboardType="number-pad"
                        />
                    </View>
                </View>

                {/* Water & Irrigation */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Water Resources</Text>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Primary Water Source</Text>
                        <View style={styles.optionsRow}>
                            {["rainwater", "borewell", "canal", "river"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        waterSource === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setWaterSource(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            waterSource === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Irrigation System</Text>
                        <View style={styles.optionsRow}>
                            {["none", "drip", "sprinkler", "flood"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        irrigationSystem === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setIrrigationSystem(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            irrigationSystem === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>
                </View>

                {/* Labor & Market */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Resources & Market</Text>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Labor Availability</Text>
                        <View style={styles.optionsRow}>
                            {["low", "moderate", "high"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        laborAvailability === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setLaborAvailability(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            laborAvailability === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Market Distance (km) *</Text>
                        <TextInput
                            style={styles.input}
                            placeholder="e.g., 15"
                            value={marketDistance}
                            onChangeText={setMarketDistance}
                            keyboardType="decimal-pad"
                        />
                    </View>
                </View>

                {/* Farming Experience */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Experience & Preferences</Text>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Farming Experience</Text>
                        <View style={styles.optionsRow}>
                            {["beginner", "intermediate", "expert"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        farmingExperience === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setFarmingExperience(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            farmingExperience === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Organic Farming Preference</Text>
                        <View style={styles.optionsRow}>
                            {["organic", "mixed", "conventional"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        organicPreference === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setOrganicPreference(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            organicPreference === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>
                </View>

                {/* Soil & Previous Crop */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Soil & Crop History</Text>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Soil Texture</Text>
                        <View style={styles.optionsRow}>
                            {["sandy", "loamy", "clayey", "silty"].map((option) => (
                                <Pressable
                                    key={option}
                                    style={[
                                        styles.optionChip,
                                        soilTexture === option && styles.optionChipSelected,
                                    ]}
                                    onPress={() => setSoilTexture(option)}
                                >
                                    <Text
                                        style={[
                                            styles.optionText,
                                            soilTexture === option && styles.optionTextSelected,
                                        ]}
                                    >
                                        {option.charAt(0).toUpperCase() + option.slice(1)}
                                    </Text>
                                </Pressable>
                            ))}
                        </View>
                    </View>

                    <View style={styles.fieldGroup}>
                        <Text style={styles.label}>Previous Crop (Optional)</Text>
                        <TextInput
                            style={styles.input}
                            placeholder="e.g., Wheat, Rice, etc."
                            value={previousCrop}
                            onChangeText={setPreviousCrop}
                        />
                    </View>
                </View>

                {error ? (
                    <View style={styles.errorBox}>
                        <Ionicons name="alert-circle" size={20} color="#dc2626" />
                        <Text style={styles.errorText}>{error}</Text>
                    </View>
                ) : null}

                <Pressable
                    style={[styles.submitButton, loading && styles.submitButtonDisabled]}
                    onPress={handleGetRefinedRecommendation}
                    disabled={loading}
                >
                    {loading ? (
                        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
                            <ActivityIndicator color="white" />
                            <Text style={styles.submitButtonText}>Getting Recommendation...</Text>
                        </View>
                    ) : (
                        <>
                            <Ionicons name="sparkles" size={22} color="white" />
                            <Text style={styles.submitButtonText}>Get Refined Recommendation</Text>
                        </>
                    )}
                </Pressable>
            </ScrollView>
        </ScreenWrapper>
    );
}

const styles = StyleSheet.create({
    header: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: hp(1),
    },
    pageTitle: {
        fontSize: hp(2.2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(1),
        paddingBottom: hp(12),
        gap: hp(2),
    },
    sectionDesc: {
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Regular",
        color: theme.colors.textLight,
        lineHeight: hp(2.1),
        marginBottom: hp(0.5),
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
        gap: hp(1.5),
    },
    cardTitle: {
        fontSize: hp(1.9),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
        marginBottom: hp(0.5),
    },
    fieldGroup: {
        gap: hp(0.8),
    },
    label: {
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textDark,
    },
    input: {
        borderWidth: 1.5,
        borderColor: "#e2e8f0",
        borderRadius: 12,
        padding: wp(3.5),
        fontSize: hp(1.6),
        fontFamily: "SFNSText-Regular",
        color: theme.colors.textDark,
        backgroundColor: "#f8fafc",
    },
    optionsRow: {
        flexDirection: "row",
        flexWrap: "wrap",
        gap: wp(2),
    },
    optionChip: {
        paddingVertical: hp(1),
        paddingHorizontal: wp(4),
        borderRadius: 20,
        borderWidth: 1.5,
        borderColor: "#e2e8f0",
        backgroundColor: "#fff",
    },
    optionChipSelected: {
        backgroundColor: theme.colors.primary,
        borderColor: theme.colors.primary,
    },
    optionText: {
        fontSize: hp(1.4),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textLight,
    },
    optionTextSelected: {
        color: "#fff",
    },
    errorBox: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(2),
        backgroundColor: "#fef2f2",
        padding: wp(3.5),
        borderRadius: 12,
        borderWidth: 1,
        borderColor: "#fecaca",
    },
    errorText: {
        flex: 1,
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Medium",
        color: "#dc2626",
    },
    submitButton: {
        backgroundColor: theme.colors.primary,
        paddingVertical: hp(1.8),
        borderRadius: 12,
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "center",
        gap: wp(2),
        shadowColor: theme.colors.primary,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
        elevation: 8,
        marginTop: hp(1),
    },
    submitButtonDisabled: {
        backgroundColor: "#94a3b8",
        shadowOpacity: 0.1,
    },
    submitButtonText: {
        color: "white",
        fontSize: hp(1.7),
        fontFamily: "SFNSDisplay-Bold",
    },
});





// app/(tabs)/fields/[id].jsx - UPDATED VERSION
import { useEffect, useMemo, useState } from "react";
import { ScrollView, StyleSheet, Text, View, Pressable } from "react-native";
import ScreenWrapper from "../../../components/ScreenWrapper";
import { theme } from "../../../constants/theme";
import { hp, wp } from "../../../helpers/common";
import { iotService } from "../../../services/iotService";
import { weatherService } from "../../../services/weatherService";
import { predictSoilParams, generateCropDescriptionBoth } from "../../../services/geminiService";
import { getCropRecommendation } from "../../../services/cropRecommendationService";
import LottieView from "lottie-react-native";
import { useFieldData, useFields } from "../../../contexts/FieldContext";
import {router, useLocalSearchParams} from "expo-router";
import Ionicons from "@expo/vector-icons/Ionicons";
import BackButton from "../../../components/BackButton";

const TTL = 5 * 60 * 1000; // 5 mins

export default function FieldDetails() {
    const { id } = useLocalSearchParams();
    const { fields, fieldData, setFieldData, lastFetchedAt, setLastFetchedAt } = useFieldData();
    const field = fields.find(f => f.id === id) || { id, name: "Field" };

    const [loading, setLoading] = useState(true);
    const [iot, setIot] = useState(null);
    const [weather, setWeather] = useState(null);
    const [predicted, setPredicted] = useState(null);
    const [recommendation, setRecommendation] = useState(null);
    const [error, setError] = useState("");

    const [englishDesc, setEnglishDesc] = useState(null);
    const [hindiDesc, setHindiDesc] = useState(null);
    const [isHindi, setIsHindi] = useState(false);

    const moisturePct = useMemo(() => {
        if (!iot?.soil && iot?.soil !== 0) return null;
        return Math.max(0, Math.min(100, Math.round((Number(iot.soil) / 4095) * 100)));
    }, [iot?.soil]);

    const temperature = iot?.temperature ?? fieldData.temperature ?? null;
    const humidity = iot?.humidity ?? fieldData.humidity ?? null;
    const rainfall = weather?.current?.precip_mm ?? fieldData.rainfall ?? null;

    const fetchAll = async () => {
        try {
            setLoading(true);

            const iotRes = await iotService.getData();
            if (!iotRes.success) throw new Error(iotRes.error || "IoT fetch failed");
            setIot(iotRes.data);

            const loc = await weatherService.getCachedOrCurrentLocation?.();
            const lat = loc?.latitude ?? 28.6139;
            const lon = loc?.longitude ?? 77.2090;
            const w = await weatherService.getCurrentWeather(lat, lon);
            if (!w.success) throw new Error(w.error || "Weather fetch failed");
            setWeather(w.data);

            const preds = await predictSoilParams({
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
            });
            setPredicted(preds);

            const payload = {
                K: preds.K,
                N: preds.N,
                P: preds.P,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                pH: preds.pH,
                rainfall: w.data?.current?.precip_mm ?? 0,
                temperature: iotRes.data.temperature,
            };
            const rec = await getCropRecommendation(payload);
            setRecommendation(rec);

            const both = await generateCropDescriptionBoth({
                crop: rec.best_crop,
                N: preds.N,
                P: preds.P,
                K: preds.K,
                pH: preds.pH,
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
            });
            setEnglishDesc(both.english);
            setHindiDesc(both.hindi);

            setFieldData({
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
                N: preds.N,
                P: preds.P,
                K: preds.K,
                pH: preds.pH,

                recommendation: rec,
                englishDesc: both.english,
                hindiDesc: both.hindi,
                // Keep existing refined recommendation
                refinedRecommendation: fieldData.refinedRecommendation,
            });

            setLastFetchedAt(Date.now());
        } catch (e) {
            console.log("üí• error:", e);
            setError(e.message || JSON.stringify(e));
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (lastFetchedAt && Date.now() - lastFetchedAt < TTL && fieldData.temperature !== null) {
            setLoading(false);
        } else {
            fetchAll();
        }
    }, [id]);

    const handleTranslate = () => setIsHindi(!isHindi);

    const hasRefinedRecommendation = fieldData.refinedRecommendation != null;

    return (
        <ScreenWrapper bg="white">
            <View style={styles.headerRow}>
                <BackButton router={router} />
                <Text style={styles.pageTitle}>{field.name}</Text>
                <Pressable onPress={fetchAll}>
                    <Ionicons name="refresh" size={26} color={theme.colors.primary} />
                </Pressable>
            </View>

            <ScrollView contentContainerStyle={styles.container}>
                {loading ? (
                    <View style={styles.loadingCard}>
                        <LottieView
                            source={require("../../../assets/animations/loading.json")}
                            style={styles.loadingAnimation}
                            autoPlay
                            loop
                            speed={1.2}
                        />
                        <Text style={styles.loadingText}>Collecting field data‚Ä¶</Text>
                    </View>
                ) : error ? (
                    <View style={styles.errorCard}>
                        <Text style={styles.errorText}>‚ö†Ô∏è {error}</Text>
                    </View>
                ) : (
                    <>
                        <View style={styles.card}>
                            <Text style={styles.cardTitle}>Current Inputs</Text>

                            <View style={styles.row}>
                                <Item label="Temperature" value={temperature ?? "‚Äî"} unit="¬∞C" source="IoT" />
                                <Item label="Humidity" value={humidity ?? "‚Äî"} unit="%" source="IoT" />
                            </View>

                            <View style={styles.row}>
                                <Item label="Moisture" value={moisturePct ?? fieldData.moisture ?? "‚Äî"} unit="%" source="IoT" />
                                <Item label="Rainfall" value={rainfall ?? 0} unit="mm" source="Weather" />
                            </View>

                            <View style={styles.separator} />

                            <View style={styles.row}>
                                <Item label="Nitrogen (N)" value={predicted?.N ?? fieldData.N ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Phosphorus (P)" value={predicted?.P ?? fieldData.P ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                            </View>
                            <View style={styles.row}>
                                <Item label="Potassium (K)" value={predicted?.K ?? fieldData.K ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Soil pH" value={predicted?.pH ?? fieldData.pH ?? "‚Äî"} unit="" source="Predicted" />
                            </View>
                        </View>

                        {/* Simple Recommendation Card */}
                        <View style={[styles.card,styles.lastCard]}>
                            <Text style={styles.cardTitle}>Today&#39;s Recommendation</Text>
                            {recommendation || fieldData.recommendation ? (
                                <View style={{ gap: hp(1) }}>
                                    <Text style={styles.recoCrop}>{(recommendation || fieldData.recommendation)?.best_crop}</Text>
                                    <Text style={styles.recoProb}>
                                        Confidence: {Number((recommendation || fieldData.recommendation)?.probability).toFixed(2)}
                                    </Text>

                                    {(englishDesc || fieldData.englishDesc) && (
                                        <>
                                            <View style={styles.descBox}>
                                                <Text style={styles.descPlaceholder}>
                                                    {isHindi
                                                        ? (hindiDesc || fieldData.hindiDesc)
                                                        : (englishDesc || fieldData.englishDesc)
                                                    }
                                                </Text>
                                            </View>

                                            <Pressable
                                                onPress={handleTranslate}
                                                style={styles.translateBtn}
                                            >
                                                <Text style={styles.translateBtnText}>
                                                    {isHindi ? "Show English" : "Translate to Hindi"}
                                                </Text>
                                            </Pressable>
                                        </>
                                    )}

                                    {/* Refine Button - Only show if no refined recommendation yet */}
                                    {!hasRefinedRecommendation && (
                                        <Pressable
                                            style={styles.refineBtn}
                                            onPress={() => router.push(`/fields/refine/${id}`)}
                                        >
                                            <Ionicons name="options-outline" size={20} color="white" />
                                            <Text style={styles.refineBtnText}>Refine My Recommendation</Text>
                                        </Pressable>
                                    )}
                                </View>
                            ) : (
                                <Text style={styles.descPlaceholder}>No recommendation available.</Text>
                            )}
                        </View>

                        {/* Refined Recommendation Section */}
                        {hasRefinedRecommendation && (
                            <>
                                <View style={styles.refinedHeaderCard}>
                                    <View style={styles.refinedHeader}>
                                        <Ionicons name="sparkles" size={24} color={theme.colors.primary} />
                                        <Text style={styles.refinedTitle}>Refined Recommendation</Text>
                                    </View>
                                    <Pressable
                                        style={styles.refineAgainBtn}
                                        onPress={() => router.push(`/fields/refine/${id}`)}
                                    >
                                        <Ionicons name="refresh-outline" size={18} color={theme.colors.primary} />
                                        <Text style={styles.refineAgainText}>Refine Again</Text>
                                    </Pressable>
                                </View>

                                {/* Top 3 Crops */}
                                <View style={styles.card}>
                                    <View style={styles.sectionHeader}>
                                        <Ionicons name="leaf" size={22} color="#22c55e" />
                                        <Text style={styles.sectionTitle}>Best Crops for Your Field</Text>
                                    </View>
                                    {fieldData.refinedRecommendation.topCrops?.map((crop, idx) => (
                                        <View key={idx} style={styles.cropCard}>
                                            <View style={styles.cropHeader}>
                                                <Text style={styles.cropRank}>#{idx + 1}</Text>
                                                <Text style={styles.cropName}>{crop.name}</Text>
                                            </View>
                                            <Text style={styles.cropReason}>{crop.reason}</Text>
                                            <View style={styles.cropMetrics}>
                                                <View style={styles.metricItem}>
                                                    <Ionicons name="trending-up" size={16} color="#22c55e" />
                                                    <Text style={styles.metricText}>{crop.expectedYield}</Text>
                                                </View>
                                                <View style={styles.metricItem}>
                                                    <Ionicons name="cash-outline" size={16} color="#22c55e" />
                                                    <Text style={styles.metricText}>{crop.estimatedProfit}</Text>
                                                </View>
                                                <View style={styles.metricItem}>
                                                    <Ionicons name="time-outline" size={16} color="#64748b" />
                                                    <Text style={styles.metricText}>{crop.growingPeriod}</Text>
                                                </View>
                                            </View>
                                        </View>
                                    ))}
                                </View>

                                {/* Crops to Avoid */}
                                <View style={styles.card}>
                                    <View style={styles.sectionHeader}>
                                        <Ionicons name="close-circle" size={22} color="#ef4444" />
                                        <Text style={styles.sectionTitle}>Crops to Avoid</Text>
                                    </View>
                                    {fieldData.refinedRecommendation.avoidCrops?.map((crop, idx) => (
                                        <View key={idx} style={styles.avoidCropCard}>
                                            <Text style={styles.avoidCropName}>{crop.name}</Text>
                                            <Text style={styles.avoidCropReason}>{crop.reason}</Text>
                                        </View>
                                    ))}
                                </View>

                                {/* Soil Improvements */}
                                <View style={styles.card}>
                                    <View style={styles.sectionHeader}>
                                        <Ionicons name="flask" size={22} color="#f59e0b" />
                                        <Text style={styles.sectionTitle}>Soil Improvement Tips</Text>
                                    </View>
                                    {fieldData.refinedRecommendation.soilImprovements?.map((tip, idx) => (
                                        <View key={idx} style={styles.tipCard}>
                                            <View style={styles.tipBullet}>
                                                <Text style={styles.tipBulletText}>{idx + 1}</Text>
                                            </View>
                                            <Text style={styles.tipText}>{tip}</Text>
                                        </View>
                                    ))}
                                </View>

                                {/* Profit Strategies */}
                                <View style={styles.card}>
                                    <View style={styles.sectionHeader}>
                                        <Ionicons name="bulb" size={22} color="#8b5cf6" />
                                        <Text style={styles.sectionTitle}>Profit Maximization Strategies</Text>
                                    </View>
                                    {fieldData.refinedRecommendation.profitStrategies?.map((strategy, idx) => (
                                        <View key={idx} style={styles.strategyCard}>
                                            <View style={styles.strategyBullet}>
                                                <Ionicons name="checkmark" size={18} color="white" />
                                            </View>
                                            <Text style={styles.strategyText}>{strategy}</Text>
                                        </View>
                                    ))}
                                </View>
                            </>
                        )}
                    </>
                )}
            </ScrollView>
        </ScreenWrapper>
    );
}

function Item({ label, value, unit, source }) {
    return (
        <View style={styles.item}>
            <Text style={styles.itemLabel}>{label}</Text>
            <Text style={styles.itemValue}>
                {value}
                {unit ? ` ${unit}` : ""} <Text style={styles.sourceTag}>({source})</Text>
            </Text>
        </View>
    );
}

const styles = StyleSheet.create({
    headerRow: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: 10,
    },
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(0.5),
        paddingBottom: hp(12),
        gap: hp(2),
    },
    pageTitle: {
        fontSize: hp(2.4),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
        gap: hp(1.2),
    },
    cardTitle: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    row: {
        flexDirection: "row",
        gap: wp(4),
    },
    item: {
        flex: 1,
        gap: hp(0.5),
    },
    itemLabel: {
        fontSize: hp(1.5),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    itemValue: {
        fontSize: hp(2.1),
        color: theme.colors.textDark,
        fontFamily: "SFNSDisplay-Bold",
    },
    sourceTag: {
        fontSize: hp(1.5),
        color: theme.colors.primary,
        fontFamily: "SFNSText-Medium",
    },
    separator: {
        height: 1,
        backgroundColor: "rgba(0,0,0,0.06)",
        marginVertical: hp(0.5),
    },
    loadingCard: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(6),
        alignItems: "center",
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
    },
    loadingAnimation: { width: wp(20), height: wp(20) },
    loadingText: {
        marginTop: hp(1),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    errorCard: {
        backgroundColor: "#fff5f5",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "#ffd6d6",
    },
    errorText: {
        color: "#c0392b",
        fontFamily: "SFNSDisplay-Bold",
    },
    recoCrop: {
        fontSize: hp(2.2),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
    recoProb: {
        fontSize: hp(1.8),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textDark,
    },
    descBox: {
        borderWidth: 1,
        borderColor: "rgba(0,0,0,0.08)",
        borderRadius: 12,
        padding: wp(3),
        backgroundColor: "#fafafa",
    },
    descPlaceholder: {
        fontSize: hp(1.6),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    translateBtn: {
        backgroundColor: theme.colors.primary,
        paddingVertical: hp(1.2),
        borderRadius: 8,
        alignItems: "center",
    },
    translateBtnText: {
        color: "white",
        fontFamily: "SFNSText-Medium",
    },
    refineBtn: {
        backgroundColor: "#8b5cf6",
        paddingVertical: hp(1.4),
        borderRadius: 10,
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "center",
        gap: wp(2),
        marginTop: hp(0.5),
        shadowColor: "#8b5cf6",
        shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.3,
        shadowRadius: 8,
        elevation: 6,
    },
    refineBtnText: {
        color: "white",
        fontFamily: "SFNSDisplay-Bold",
        fontSize: hp(1.6),
    },

    // Refined Recommendation Styles
    refinedHeaderCard: {
        backgroundColor: "#f0fdf4",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 2,
        borderColor: "rgba(34, 197, 94, 0.3)",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
    },
    refinedHeader: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(2),
    },
    refinedTitle: {
        fontSize: hp(2.1),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
    refineAgainBtn: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(1.5),
        paddingVertical: hp(0.8),
        paddingHorizontal: wp(3),
        backgroundColor: "white",
        borderRadius: 8,
        borderWidth: 1,
        borderColor: theme.colors.primary,
    },
    refineAgainText: {
        fontSize: hp(1.4),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.primary,
    },

    // Section Headers
    sectionHeader: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(2),
        marginBottom: hp(0.5),
    },
    sectionTitle: {
        fontSize: hp(1.9),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },

    // Crop Cards
    cropCard: {
        backgroundColor: "#f8fafc",
        borderRadius: 12,
        padding: wp(3.5),
        borderWidth: 1,
        borderColor: "#e2e8f0",
        gap: hp(0.8),
    },
    cropHeader: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(2),
        marginBottom: hp(0.3),
    },
    cropRank: {
        fontSize: hp(1.5),
        fontFamily: "SFNSDisplay-Heavy",
        color: "#22c55e",
        backgroundColor: "rgba(34, 197, 94, 0.1)",
        paddingHorizontal: wp(2.5),
        paddingVertical: hp(0.3),
        borderRadius: 6,
    },
    cropName: {
        fontSize: hp(1.9),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
        flex: 1,
    },
    cropReason: {
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Regular",
        color: theme.colors.textLight,
        lineHeight: hp(2.1),
    },
    cropMetrics: {
        flexDirection: "row",
        flexWrap: "wrap",
        gap: wp(3),
        marginTop: hp(0.5),
    },
    metricItem: {
        flexDirection: "row",
        alignItems: "center",
        gap: wp(1),
    },
    metricText: {
        fontSize: hp(1.4),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textDark,
    },

    // Avoid Crops
    avoidCropCard: {
        backgroundColor: "#fef2f2",
        borderRadius: 10,
        padding: wp(3),
        borderWidth: 1,
        borderColor: "#fecaca",
        gap: hp(0.5),
    },
    avoidCropName: {
        fontSize: hp(1.7),
        fontFamily: "SFNSDisplay-Bold",
        color: "#dc2626",
    },
    avoidCropReason: {
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Regular",
        color: "#991b1b",
        lineHeight: hp(2),
    },

    // Tips
    tipCard: {
        flexDirection: "row",
        gap: wp(3),
        alignItems: "flex-start",
    },
    tipBullet: {
        width: 24,
        height: 24,
        borderRadius: 12,
        backgroundColor: "#f59e0b",
        alignItems: "center",
        justifyContent: "center",
        marginTop: hp(0.2),
    },
    tipBulletText: {
        fontSize: hp(1.4),
        fontFamily: "SFNSDisplay-Bold",
        color: "white",
    },
    tipText: {
        flex: 1,
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Regular",
        color: theme.colors.textDark,
        lineHeight: hp(2.1),
    },

    // Strategies
    strategyCard: {
        flexDirection: "row",
        gap: wp(3),
        alignItems: "flex-start",
        backgroundColor: "#faf5ff",
        padding: wp(3),
        borderRadius: 10,
        borderWidth: 1,
        borderColor: "#e9d5ff",
    },
    strategyBullet: {
        width: 24,
        height: 24,
        borderRadius: 12,
        backgroundColor: "#8b5cf6",
        alignItems: "center",
        justifyContent: "center",
        marginTop: hp(0.2),
    },
    strategyText: {
        flex: 1,
        fontSize: hp(1.5),
        fontFamily: "SFNSText-Regular",
        color: theme.colors.textDark,
        lineHeight: hp(2.1),
    },
    lastCard: {
        marginBottom: 130,
    }
});







// app/(tabs)/fields/_layout.jsx
import { Stack } from "expo-router";

export default function FieldsStackLayout() {
    return (
        <Stack screenOptions={{ headerShown: false }} />
    );
}





// app/(tabs)/fields/index.jsx
import { View, Text, Pressable, StyleSheet, Alert, ScrollView } from "react-native";
import ScreenWrapper from "../../../components/ScreenWrapper";
import { hp, wp } from "../../../helpers/common";
import { theme } from "../../../constants/theme";
import { useRouter } from "expo-router";
import { useFields } from "../../../contexts/FieldContext";

export default function FieldsIndex() {
    const router = useRouter();
    const { fields } = useFields(); // future-proof list

    return (
        <ScreenWrapper bg="white">
            <ScrollView contentContainerStyle={styles.container}>
                <Text style={styles.title}>Your Fields</Text>

                {fields.map((f) => (
                    <Pressable
                        key={f.id}
                        style={styles.card}
                        onPress={() => router.push(`/fields/${f.id}`)}
                    >
                        <Text style={styles.cardTitle}>{f.name}</Text>
                        <Text style={styles.small}>Tap to open details</Text>
                    </Pressable>
                ))}

                <Pressable
                    style={[styles.card, styles.addCard]}
                    onPress={() =>
                        // Alert.alert("Coming Soon", "Multiple fields support is coming soon!")
                        Alert.alert("Coming Soon", "Oooo Madarchod, Kal Aana!")
                    }
                >
                    <Text style={styles.addText}>+ Add Field</Text>
                </Pressable>
            </ScrollView>
        </ScreenWrapper>
    );
}

const styles = StyleSheet.create({
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        gap: hp(2),
        paddingBottom: hp(20),
    },
    title: {
        fontSize: hp(2.4),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
        marginBottom: hp(1),
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(5),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
    },
    cardTitle: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    small: {
        marginTop: hp(0.5),
        fontSize: hp(1.5),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    addCard: { alignItems: "center" },
    addText: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
});









// =============================
// /services/geminiService.js
// =============================

const GEMINI_API_KEY = process.env.EXPO_PUBLIC_GEMINI_API_KEY;
const GEMINI_ENDPOINT =
    "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent";


function buildPrompt({ temperature, humidity, moisture, rainfall }) {
    return `You are an agronomy assistant. Given current field conditions, estimate soil macronutrients and pH for use in a crop recommendation model.

Return ONLY a strict minified JSON object with numeric values (no comments, no text around it), like:
{"N":80,"P":35,"K":40,"pH":6.5}

Constraints:
- N, P, K are in kg/ha, integers 0-300
- pH is 3.5 - 9.5 (one decimal)
- If information is insufficient, infer a reasonable value from typical Indian loamy soils in Kharif season.

Conditions:
- temperature_C: ${temperature}
- humidity_pct: ${humidity}
- soil_moisture_pct: ${moisture}
- rainfall_mm: ${rainfall}
`;
}

function extractJsonFromText(text) {
    try {
        // If it's already pure JSON
        return JSON.parse(text);
    } catch (_) {
        // Try to locate the first {...} block
        const start = text.indexOf("{");
        const end = text.lastIndexOf("}");
        if (start !== -1 && end !== -1 && end > start) {
            const jsonSlice = text.slice(start, end + 1);
            return JSON.parse(jsonSlice);
        }
        throw new Error("Gemini response did not contain valid JSON.");
    }
}

export async function predictSoilParams({ temperature, humidity, moisture, rainfall }) {
    if (!GEMINI_API_KEY) {
        throw new Error("Missing EXPO_PUBLIC_GEMINI_API_KEY");
    }

    const body = {
        contents: [
            {
                role: "user",
                parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
            },
        ],
        generationConfig: {
            temperature: 0.4,
            maxOutputTokens: 128,
        },
    };

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [
                {
                    role: "user",
                    parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
                },
            ],
        }),
    });


    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
    const parsed = extractJsonFromText(text);

    const N = Math.max(0, Math.min(300, Math.round(Number(parsed.N))));
    const P = Math.max(0, Math.min(300, Math.round(Number(parsed.P))));
    const K = Math.max(0, Math.min(300, Math.round(Number(parsed.K))));
    const pH = Math.max(3.5, Math.min(9.5, Number(parsed.pH)));

    if ([N, P, K].some((v) => Number.isNaN(v)) || Number.isNaN(pH)) {
        throw new Error("Gemini returned invalid numbers");
    }

    return { N, P, K, pH: Number(pH.toFixed(1)) };
}

// --- Helpers: robust JSON extraction/parsing from LLM text ---
// Finds the first balanced {...} JSON object (ignores braces inside quotes)
function findFirstJsonObject(s) {
    if (!s) return null;

    // strip common wrappers
    let t = s.trim().replace(/```json/gi, "").replace(/```/g, "");
    // also strip any preface before the first '{'
    const firstBrace = t.indexOf("{");
    if (firstBrace > 0) t = t.slice(firstBrace);

    let depth = 0;
    let inString = false;
    let escape = false;

    for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        if (inString) {
            if (escape) {
                escape = false;
            } else if (ch === "\\") {
                escape = true;
            } else if (ch === "\"") {
                inString = false;
            }
            continue;
        }

        if (ch === "\"") {
            inString = true;
            continue;
        }
        if (ch === "{") {
            depth++;
            continue;
        }
        if (ch === "}") {
            depth--;
            if (depth === 0) {
                // slice inclusive of this closing brace
                return t.slice(0, i + 1);
            }
            continue;
        }
    }
    return null; // not found
}

function safeParseGeminiJson(text) {
    const jsonSlice = findFirstJsonObject(text);
    if (!jsonSlice) throw new Error("No JSON object found in Gemini response.");
    // Clean any stray leading commas/colons/newlines
    const clean = jsonSlice.replace(/^[,:\\s]+/, "");
    return JSON.parse(clean);
}

// =====================
// ONE-CALL: English + Hindi description
// =====================
export async function generateCropDescriptionBoth({
                                                      crop, N, P, K, pH, temperature, humidity, moisture, rainfall
                                                  }) {
    const prompt = `
You are an agriculture advisor.
Generate TWO versions of a very short advice (max 3 lines) for a farmer based on this crop and field data.

crop=${crop}
N=${N}, P=${P}, K=${K}, pH=${pH}
temperature=${temperature}C, humidity=${humidity}%, moisture=${moisture}%, rainfall=${rainfall}mm

Return EXACTLY and ONLY this JSON (no extra words, no backticks):
{"english":"<simple english, farmer-friendly>", "hindi":"<simple Hindi, farmer-friendly>"}
`;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const raw = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

    try {
        const obj = safeParseGeminiJson(raw);
        // Minimal sanity
        if (!obj || typeof obj !== "object") throw new Error("Parsed result is not an object");
        if (typeof obj.english !== "string" || typeof obj.hindi !== "string") {
            throw new Error("Parsed JSON missing 'english' or 'hindi' strings");
        }
        return obj; // { english, hindi }
    } catch (e) {
        // Log raw to console to debug quickly, but don't crash the app silently
        console.log("üîé Gemini raw description text =>", raw);
        throw e;
    }
}

//
// // =====================
// // translate to Hindi
// // =====================
// export async function translateToHindi(text) {
//     const prompt = `Translate this to simple Hindi suitable for farmers:\n${text}`;
//
//     const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
//         method:"POST",
//         headers:{ "Content-Type":"application/json" },
//         body:JSON.stringify({
//             contents:[{role:"user", parts:[{text:prompt}]}]
//         })
//     });
//
//     const data = await res.json();
//     return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
// }



// services/geminiService.js - ADD THIS NEW FUNCTION

// ... (keep all existing functions) ...

// =====================
// REFINED RECOMMENDATION
// {"topCrops":[{"name":"crop","reason":"brief","expectedYield":"X tons/ac","estimatedProfit":"‚ÇπX/ac","growingPeriod":"X mo"}],"avoidCrops":[{"name":"crop","reason":"brief"}],"soilImprovements":["tip","tip","tip"],"profitStrategies":["strategy","strategy","strategy"]}`;
// =====================
export async function getRefinedRecommendation(data) {
    const prompt = `Agricultural advisor API. JSON only response.

Data: ${data.temperature}¬∞C, ${data.humidity}% humidity, ${data.moisture}% moisture, ${data.rainfall}mm rain, NPK: ${data.N}/${data.P}/${data.K}, pH ${data.pH}, ${data.farmSize}ac, ‚Çπ${data.budget}, ${data.laborAvailability} labor, ${data.irrigationSystem} irrigation, ${data.marketDistance}km market, ${data.soilTexture} soil.

Return 3 crops to grow, 2 to avoid, 3 general soil improvement tips, 3 profit strategies(must be 4-8 words max).
Return all of this without any newline characters or formatting, ONLY this JSON:
{"topCrops":[{"name":"crop","reason":"brief","expectedYield","estimatedProfit","growingPeriod"}],"avoidCrops":[{"name":"crop","reason":"brief"}],"soilImprovements":["tip","tip","tip"], "profitStrategies":["strategy","strategy","strategy"]}`;

    console.log("üì® Sending request to Gemini...");

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            generationConfig: {
                temperature: 0.1,
                maxOutputTokens: 8192,
                candidateCount: 1,
            },
            safetySettings: [
                {
                    category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                    threshold: "BLOCK_NONE"
                }
            ]
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        console.error("‚ùå API Error:", res.status, errText);
        throw new Error(`Gemini API error: ${res.status}`);
    }

    const responseData = await res.json();
    console.log("üì¶ Full API Response:", JSON.stringify(responseData, null, 2));

    // Check for blocked content or errors
    if (responseData.promptFeedback?.blockReason) {
        console.error("‚ùå Content blocked:", responseData.promptFeedback.blockReason);
        throw new Error(`Content blocked: ${responseData.promptFeedback.blockReason}`);
    }

    const candidate = responseData?.candidates?.[0];
    const raw = candidate?.content?.parts?.[0]?.text ?? "";

    if (!candidate) {
        console.error("‚ùå No candidates in response");
        throw new Error("No response from AI. Please try again.");
    }

    if (candidate.finishReason === "MAX_TOKENS") {
        console.warn("‚ö†Ô∏è Response truncated (MAX_TOKENS). Attempting to parse partial JSON...");

        // Try to close the JSON properly
        let partialJson = raw.trim();

        // Remove markdown if present
        partialJson = partialJson.replace(/```json\n?/g, "").replace(/```/g, "");

        // Count braces to try to close JSON
        const openBraces = (partialJson.match(/\{/g) || []).length;
        const closeBraces = (partialJson.match(/\}/g) || []).length;

        if (openBraces > closeBraces) {
            // Add missing closing braces
            partialJson += ']'.repeat(Math.max(0, (partialJson.match(/\[/g) || []).length - (partialJson.match(/\]/g) || []).length));
            partialJson += '}'.repeat(openBraces - closeBraces);
            console.log("üîß Added closing braces to partial JSON");
        }

        try {
            const parsed = JSON.parse(partialJson);
            console.log("‚úÖ Successfully parsed partial JSON");

            // Fill in missing data with defaults
            return {
                topCrops: (parsed.topCrops || []).map((crop, idx) => ({
                    name: crop.name || `Crop ${idx + 1}`,
                    reason: crop.reason || "Suitable for your conditions",
                    expectedYield: crop.expectedYield || "Varies",
                    estimatedProfit: crop.estimatedProfit || "‚Çπ20,000-50,000/acre",
                    growingPeriod: crop.growingPeriod || "3-4 months"
                })).concat(
                    Array(Math.max(0, 3 - (parsed.topCrops || []).length))
                        .fill(null)
                        .map((_, idx) => ({
                            name: ["Wheat", "Rice", "Maize"][idx],
                            reason: "Alternative crop for your soil and climate",
                            expectedYield: "Varies by season",
                            estimatedProfit: "‚Çπ25,000-40,000/acre",
                            growingPeriod: "3-4 months"
                        }))
                ).slice(0, 3),
                avoidCrops: (parsed.avoidCrops || []).concat(
                    Array(Math.max(0, 2 - (parsed.avoidCrops || []).length))
                        .fill(null)
                        .map(() => ({
                            name: "Check with local expert",
                            reason: "Depends on specific local conditions"
                        }))
                ).slice(0, 2),
                soilImprovements: (parsed.soilImprovements || []).concat([
                    "Add organic compost regularly",
                    "Test soil nutrients annually",
                    "Maintain proper drainage"
                ]).slice(0, 3),
                profitStrategies: (parsed.profitStrategies || []).concat([
                    "Sell directly at local markets for better prices",
                    "Plan crops according to market demand",
                    "Use efficient irrigation to reduce costs"
                ]).slice(0, 3)
            };
        } catch (e) {
            console.error("‚ùå Could not parse even with fixes:", e.message);
            // Fall through to normal parsing
        }
    }

    // const raw = candidate?.content?.parts?.[0]?.text ?? "";

    console.log("üîç Gemini raw text length:", raw.length);
    console.log("üîç Gemini raw response (first 800 chars):", raw.substring(0, 800));

    // If response is empty
    if (!raw || raw.trim().length === 0) {
        throw new Error("Gemini returned empty response");
    }

    // Try multiple parsing strategies
    let parsedData = null;
    let parseError = null;

    // Strategy 1: Direct parse if it starts with {
    try {
        const trimmed = raw.trim();
        if (trimmed.startsWith('{')) {
            parsedData = JSON.parse(trimmed);
            console.log("‚úÖ Parsed with Strategy 1 (direct parse)");
        }
    } catch (e) {
        parseError = e;
    }

    // Strategy 2: Find JSON between ```json and ``` or just between ```
    if (!parsedData) {
        try {
            const codeBlockMatch = raw.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
            if (codeBlockMatch && codeBlockMatch[1]) {
                parsedData = JSON.parse(codeBlockMatch[1]);
                console.log("‚úÖ Parsed with Strategy 2 (markdown code block)");
            }
        } catch (e) {
            parseError = e;
        }
    }

    // Strategy 3: Use robust parser
    if (!parsedData) {
        try {
            parsedData = safeParseGeminiJson(raw);
            console.log("‚úÖ Parsed with Strategy 3 (robust parser)");
        } catch (e) {
            parseError = e;
        }
    }

    // Strategy 4: Regex to find any JSON object
    if (!parsedData) {
        try {
            const jsonMatch = raw.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                parsedData = JSON.parse(jsonMatch[0]);
                console.log("‚úÖ Parsed with Strategy 4 (regex match)");
            }
        } catch (e) {
            parseError = e;
        }
    }

    // If all strategies failed
    if (!parsedData) {
        console.error("‚ùå All parsing strategies failed");
        console.error("‚ùå Full response:", raw);
        console.error("‚ùå Last parse error:", parseError?.message);
        throw new Error("Could not parse AI response. Please try again.");
    }

    // Validate structure
    if (!parsedData.topCrops || !Array.isArray(parsedData.topCrops) || parsedData.topCrops.length === 0) {
        console.error("‚ùå Invalid structure:", parsedData);
        throw new Error("AI returned incomplete data. Please try again.");
    }

    // Ensure all required fields with defaults
    const validated = {
        topCrops: parsedData.topCrops.slice(0, 3).map(crop => ({
            name: crop.name || "Unknown Crop",
            reason: crop.reason || "Suitable for current conditions",
            expectedYield: crop.expectedYield || "Data not available",
            estimatedProfit: crop.estimatedProfit || "Varies",
            growingPeriod: crop.growingPeriod || "Standard season"
        })),
        avoidCrops: (parsedData.avoidCrops || []).map(crop => ({
            name: crop.name || "Unknown",
            reason: crop.reason || "Not suitable for current conditions"
        })),
        soilImprovements: parsedData.soilImprovements || ["Add organic matter", "Test soil regularly", "Maintain proper drainage"],
        profitStrategies: parsedData.profitStrategies || ["Focus on market demand", "Reduce input costs", "Improve crop quality"]
    };

    console.log("‚úÖ Validated refined data:", JSON.stringify(validated, null, 2));
    return validated;
}


// =====================
// HELP: Ask AI with REFINED context
// =====================
export async function helpAnswer({ question, context }) {
    if (!question || !question.trim()) return "";

    // Build context string including refined data if available
    let contextString = `
Temperature: ${context.temperature}¬∞C
Humidity: ${context.humidity}%
Moisture: ${context.moisture}%
Rainfall: ${context.rainfall}mm
N: ${context.N}
P: ${context.P}
K: ${context.K}
pH: ${context.pH}`;

    // Add refined recommendation context if available
    if (context.refinedRecommendation) {
        const refined = context.refinedRecommendation;
        contextString += `

REFINED RECOMMENDATION DATA:
Top Recommended Crops: ${refined.topCrops?.map(c => c.name).join(", ")}
Crops to Avoid: ${refined.avoidCrops?.map(c => c.name).join(", ")}
Soil Improvements Needed: ${refined.soilImprovements?.join("; ")}`;
    }

    const prompt = `
You are an agriculture advisor inside AgroSync app.
This is the current field context:

${contextString}

User question:
${question.trim()}

Answer in 3-5 short lines, simple farmer-friendly English.
Do not use codeblocks or markdown.
If the question relates to refined recommendations, use that detailed context to provide specific advice.
`;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini Help error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
}