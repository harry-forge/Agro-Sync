app/(tabs)/home.jsx:

import * as Location from 'expo-location';
import { router } from "expo-router";
import { StatusBar } from "expo-status-bar";
import LottieView from 'lottie-react-native';
import { useEffect, useRef, useState } from 'react';
import { ActivityIndicator, Animated, Pressable, ScrollView, StyleSheet, Text, View } from 'react-native';
import Button from "../../components/Button";
import ScreenWrapper from "../../components/ScreenWrapper";
import { theme } from "../../constants/theme";
import { useAuth } from "../../contexts/AuthContext";
import { hp, wp } from "../../helpers/common";
import { iotService } from "../../services/iotService";
import { weatherService } from "../../services/weatherService";

const Home = () => {
    const { user, logout } = useAuth();
    const [greeting, setGreeting] = useState('');
    const [loading, setLoading] = useState(false);
    const [displayedText, setDisplayedText] = useState('');
    const [isHindi, setIsHindi] = useState(false);
    const [showCursor, setShowCursor] = useState(true);
    const [weatherCondition, setWeatherCondition] = useState('sunny');
    const [currentLottieSource, setCurrentLottieSource] = useState(require('../../assets/animations/sunny.json'));
    const [weatherData, setWeatherData] = useState(null);
    const [weatherLoading, setWeatherLoading] = useState(true);
    const [location, setLocation] = useState({ latitude: null, longitude: null });
    const [iotData, setIotData] = useState(null);
    const [iotLoading, setIotLoading] = useState(true);
    const [lastIotUpdate, setLastIotUpdate] = useState(null);
    const [isIotOnline, setIsIotOnline] = useState(false);
    const [healthData, setHealthData] = useState(null);
    const [healthLoading, setHealthLoading] = useState(false);
    const [showHealthCheck, setShowHealthCheck] = useState(false);
    const previousTimestampRef = useRef(null);
    const lottieRef = useRef(null);
    const fadeAnim = useRef(new Animated.Value(1)).current;
    const moveUpAnim = useRef(new Animated.Value(0)).current;
    const cursorAnim = useRef(new Animated.Value(1)).current;
    const weatherIconAnim = useRef(new Animated.Value(1)).current;
    const bounceAnim = useRef(new Animated.Value(1)).current;
    const healthModalFadeAnim = useRef(new Animated.Value(0)).current;
    const healthModalScaleAnim = useRef(new Animated.Value(0.8)).current;
    const statusFadeAnim = useRef(new Animated.Value(1)).current;

    // Get time-based greeting in both languages
    const getGreeting = (useHindi = false) => {
        const hour = new Date().getHours();

        const greetings = {
            english: {
                morning: 'Good Morning',
                afternoon: 'Good Afternoon',
                evening: 'Good Evening',
                night: 'Good Night'
            },
            hindi: {
                morning: '‡§∏‡•Å‡§™‡•ç‡§∞‡§≠‡§æ‡§§',
                afternoon: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á',
                evening: '‡§∂‡•Å‡§≠ ‡§∏‡§Ç‡§ß‡•ç‡§Ø‡§æ',
                night: '‡§∂‡•Å‡§≠ ‡§∞‡§æ‡§§‡•ç‡§∞‡§ø'
            }
        };

        const lang = useHindi ? greetings.hindi : greetings.english;

        if (hour >= 5 && hour < 12) return lang.morning;
        if (hour >= 12 && hour < 17) return lang.afternoon;
        if (hour >= 17 && hour < 21) return lang.evening;
        return lang.night;
    };

    // Typing effect animation
    const animateTypingEffect = (newText) => {
        Animated.parallel([
            Animated.timing(fadeAnim, {
                toValue: 0,
                duration: 200,
                useNativeDriver: true,
            }),
            Animated.timing(moveUpAnim, {
                toValue: -2,
                duration: 200,
                useNativeDriver: true,
            })
        ]).start(() => {
            // Reset displayed text and position but DO NOT set greeting yet
            setDisplayedText('');
            moveUpAnim.setValue(0);

            // Fade in (visual only)
            Animated.timing(fadeAnim, {
                toValue: 1,
                duration: 300,
                useNativeDriver: true,
            }).start();

            const fullText = `${newText}, ${getUserName()}`;
            let currentIndex = 0;

            const typingInterval = setInterval(() => {
                if (currentIndex <= fullText.length) {
                    setDisplayedText(fullText.substring(0, currentIndex));
                    currentIndex++;
                } else {
                    clearInterval(typingInterval);
                    // now update greeting state (if you need it elsewhere)
                    setGreeting(newText);
                }
            }, 80);
        });
    };


    // Cursor blinking animation
    useEffect(() => {
        const blinkCursor = () => {
            Animated.sequence([
                Animated.timing(cursorAnim, {
                    toValue: 0,
                    duration: 500,
                    useNativeDriver: false, // <-- FIXED
                }),
                Animated.timing(cursorAnim, {
                    toValue: 1,
                    duration: 500,
                    useNativeDriver: false, // <-- FIXED
                })
            ]).start(() => blinkCursor());
        };

        blinkCursor();
    }, []);

    // Weather icon animation effect
    useEffect(() => {
        const pulseWeatherIcon = () => {
            Animated.sequence([
                Animated.timing(bounceAnim, {
                    toValue: 1.1,
                    duration: 2000,
                    useNativeDriver: true,
                }),
                Animated.timing(bounceAnim, {
                    toValue: 1,
                    duration: 2000,
                    useNativeDriver: true,
                })
            ]).start(() => pulseWeatherIcon());
        };

        pulseWeatherIcon();
    }, []);

    // Initialize greeting, weather and set up animations
    useEffect(() => {
        // Set initial greeting and start typing effect
        const initialGreeting = getGreeting(false);
        setGreeting(initialGreeting);

        // Test API key first
        weatherService.testApiKey();

        // Get user location and fetch weather
        getUserLocation();

        // Fetch IoT data
        fetchIoTData();

        // Refresh IoT data every 30 seconds
        const iotInterval = setInterval(() => {
            fetchIoTData();
        }, 30000); // 30 seconds

        // Start initial typing effect
        setTimeout(() => {
            animateTypingEffect(initialGreeting);
        }, 500); // Small delay before starting

        // Language animation - switch every 5 seconds (increased for typing effect)
        const languageInterval = setInterval(() => {
            setIsHindi(prev => {
                const newIsHindi = !prev;
                const newGreeting = getGreeting(newIsHindi);
                animateTypingEffect(newGreeting);
                return newIsHindi;
            });
        }, 5000); // Switch every 5 seconds to allow typing animation to complete

        return () => {
            clearInterval(languageInterval);
            clearInterval(iotInterval);
        };
    }, []);

    // Fetch weather when location is available
    useEffect(() => {
        console.log('Location changed:', location);
        if (location.latitude && location.longitude) {
            console.log('Fetching weather for location:', location.latitude, location.longitude);
            fetchWeatherData(location.latitude, location.longitude);

            // Refresh weather every 10 minutes
            const weatherInterval = setInterval(() => {
                fetchWeatherData(location.latitude, location.longitude);
            }, 600000); // 10 minutes

            return () => clearInterval(weatherInterval);
        } else {
            console.log('Location not available yet');
        }
    }, [location]);

    // Re-run greeting when user data changes
    useEffect(() => {
        if (user) {
            const newGreeting = getGreeting(isHindi);
            animateTypingEffect(newGreeting);
        }
    }, [user]);

    // Fetch weather data from API
    const fetchWeatherData = async (lat, lon) => {
        try {
            setWeatherLoading(true);
            const result = await weatherService.getCurrentWeather(lat, lon);

            if (result.success) {
                setWeatherData(result.data);

                // Update animation based on real weather
                const condition = mapWeatherCondition(result.data.current.condition.code, result.data.current.is_day);
                setWeatherCondition(condition);
                setCurrentLottieSource(weatherAnimations[condition] || weatherAnimations['sunny']);
            } else {
                console.error('Weather API error:', result.error);
            }
        } catch (error) {
            console.error('Error fetching weather:', error);
        } finally {
            setWeatherLoading(false);
        }
    };

    // Fetch IoT data from API
    const fetchIoTData = async () => {
        try {
            // Only show loading on initial fetch (when iotData is null)
            if (!iotData) {
                setIotLoading(true);
            }

            const result = await iotService.getData();s

            if (result.success) {
                const newData = result.data;
                console.log('IoT data loaded:', newData);

                // Store previous online status
                const previousOnlineStatus = isIotOnline;

                // Compare timestamps to determine online/offline status
                let newOnlineStatus = false;
                if (previousTimestampRef.current !== null) {
                    // We have previous data, compare timestamps
                    if (previousTimestampRef.current === newData.timestamp) {
                        // Timestamp is SAME as previous - device is OFFLINE
                        newOnlineStatus = false;
                        console.log('IoT device OFFLINE - timestamp unchanged:', newData.timestamp, '(previous:', previousTimestampRef.current + ')');
                    } else {
                        // Timestamp is DIFFERENT - device is ONLINE
                        newOnlineStatus = true;
                        setLastIotUpdate(new Date());
                        console.log('IoT device ONLINE - new timestamp:', newData.timestamp, '(previous:', previousTimestampRef.current + ')');
                    }
                } else {
                    // First load - check if timestamp is "Never" (device offline from start)
                    if (newData.timestamp === "Never") {
                        newOnlineStatus = false;
                        console.log('IoT device OFFLINE - timestamp is "Never"');
                    } else {
                        newOnlineStatus = true;
                        setLastIotUpdate(new Date());
                        console.log('IoT device ONLINE - first load, timestamp:', newData.timestamp);
                    }
                }

                // Trigger fade animation if status changed
                if (previousOnlineStatus !== newOnlineStatus) {
                    // Fade out
                    Animated.timing(statusFadeAnim, {
                        toValue: 0,
                        duration: 300,
                        useNativeDriver: true,
                    }).start(() => {
                        // Update status
                        setIsIotOnline(newOnlineStatus);

                        // Fade in
                        Animated.timing(statusFadeAnim, {
                            toValue: 1,
                            duration: 300,
                            useNativeDriver: true,
                        }).start();
                    });
                } else {
                    // No status change, just update
                    setIsIotOnline(newOnlineStatus);
                }

                // Store current timestamp for next comparison
                previousTimestampRef.current = newData.timestamp;
                setIotData(newData);
            } else {
                console.error('IoT API error:', result.error);
                setIsIotOnline(false);
            }
        } catch (error) {
            console.error('Error fetching IoT data:', error);
            setIsIotOnline(false);
        } finally {
            // Only hide loading if it was shown (initial fetch)
            if (!iotData) {
                setIotLoading(false);
            }
        }
    };

    // Fetch health check data from API
    const fetchHealthCheck = async () => {
        try {
            setHealthLoading(true);
            setShowHealthCheck(true); // Show modal with animation immediately

            // Reset and trigger fade-in animation
            healthModalFadeAnim.setValue(0);
            healthModalScaleAnim.setValue(0.8);

            Animated.parallel([
                Animated.timing(healthModalFadeAnim, {
                    toValue: 1,
                    duration: 400,
                    useNativeDriver: true,
                }),
                Animated.spring(healthModalScaleAnim, {
                    toValue: 1,
                    tension: 50,
                    friction: 7,
                    useNativeDriver: true,
                })
            ]).start();

            console.log('Analyzing sensor health...');

            if (!iotData) {
                console.log('No IoT data available for health check');
                await new Promise(resolve => setTimeout(resolve, 4000)); // Wait 4 seconds
                setHealthData(null);
                setHealthLoading(false);
                return;
            }

            // Wait 4 seconds while animation plays and "checking sensors"
            await new Promise(resolve => setTimeout(resolve, 4000));

            // Generate health status based on sensor values
            const healthStatus = {
                temperature: analyzeTemperatureSensor(iotData.temperature),
                humidity: analyzeHumiditySensor(iotData.humidity),
                soil: analyzeSoilSensor(iotData.soil),
                light: analyzeLightSensor(iotData.light),
                rain: analyzeRainSensor(iotData.rain),
                overall: isIotOnline ? 'System Online' : 'System Offline'
            };

            console.log('Health check analysis:', healthStatus);
            setHealthData(healthStatus);
        } catch (error) {
            console.error('Error analyzing health check:', error);
        } finally {
            setHealthLoading(false);
        }
    };

    // Analyze temperature sensor health
    const analyzeTemperatureSensor = (temp) => {
        if (!isIotOnline || temp === 0) return 'ERROR - No Data';
        if (temp < 0 || temp > 50) return 'WARNING - Out of Range';
        if (temp >= 10 && temp <= 35) return 'OK - Optimal';
        return 'OK - Acceptable';
    };

    // Analyze humidity sensor health
    const analyzeHumiditySensor = (humidity) => {
        if (!isIotOnline || humidity === 0) return 'ERROR - No Data';
        if (humidity < 0 || humidity > 100) return 'WARNING - Invalid';
        if (humidity >= 30 && humidity <= 80) return 'OK - Optimal';
        return 'OK - Acceptable';
    };

    // Analyze soil moisture sensor health
    const analyzeSoilSensor = (soil) => {
        if (!isIotOnline) return 'ERROR - No Data';
        if (soil < 0 || soil > 4095) return 'WARNING - Invalid';
        const percentage = (soil / 4095) * 100;
        if (percentage >= 20 && percentage <= 80) return 'OK - Optimal';
        if (percentage < 10) return 'WARNING - Too Dry';
        if (percentage > 90) return 'WARNING - Too Wet';
        return 'OK - Acceptable';
    };

    // Analyze light sensor health
    const analyzeLightSensor = (light) => {
        if (!isIotOnline || light === 'N/A') return 'ERROR - No Data';
        if (light === 'Dark' || light === 'Bright' || light === 'Moderate') return 'OK - Working';
        return 'WARNING - Unknown State';
    };

    // Analyze rain sensor health
    const analyzeRainSensor = (rain) => {
        if (!isIotOnline || rain === 0) return 'ERROR - No Data';
        if (rain < 0 || rain > 4095) return 'WARNING - Invalid';
        return 'OK - Working';
    };

    // Get user's first name
    const getUserName = () => {
        if (user?.name) return user.name.split(' ')[0];
        if (user?.user_metadata?.name) return user.user_metadata.name.split(' ')[0];
        if (user?.email) return user.email.split('@')[0];
        return 'Friend';
    };

    // Get user's location
    const getUserLocation = async () => {
        try {
            console.log('Requesting location permissions...');
            // Request permissions
            let { status } = await Location.requestForegroundPermissionsAsync();
            console.log('Location permission status:', status);

            if (status !== 'granted') {
                console.log('Permission to access location was denied, using fallback');
                // Fallback to a default location (New Delhi)
                setLocation({
                    latitude: 28.6139,
                    longitude: 77.2090
                });
                return;
            }

            console.log('Getting current position...');
            // Get current location
            let location = await Location.getCurrentPositionAsync({
                accuracy: Location.Accuracy.Balanced,
                timeout: 10000,
            });

            console.log('Got location:', location.coords.latitude, location.coords.longitude);
            setLocation({
                latitude: location.coords.latitude,
                longitude: location.coords.longitude
            });
        } catch (error) {
            console.log('Location error:', error);
            // Fallback to a default location (New Delhi)
            console.log('Using fallback location: New Delhi');
            setLocation({
                latitude: 28.6139,
                longitude: 77.2090
            });
        }
    };

    // Map weather API condition codes to our animations
    const mapWeatherCondition = (code, isDay) => {
        const conditionMap = {
            1000: isDay ? 'sunny' : 'clear-night', // Sunny/Clear
            1003: 'cloudy', // Partly cloudy
            1006: 'cloudy', // Cloudy
            1009: 'cloudy', // Overcast
            1030: 'cloudy', // Mist
            1063: 'rainy', // Patchy rain possible
            1066: 'storm', // Patchy snow possible
            1069: 'storm', // Patchy sleet possible
            1072: 'storm', // Patchy freezing drizzle possible
            1087: 'storm', // Thundery outbreaks possible
            1114: 'windy', // Blowing snow
            1117: 'storm', // Blizzard
            1135: 'cloudy', // Fog
            1147: 'cloudy', // Freezing fog
            1150: 'rainy', // Patchy light drizzle
            1153: 'rainy', // Light drizzle
            1168: 'rainy', // Freezing drizzle
            1171: 'rainy', // Heavy freezing drizzle
            1180: 'rainy', // Patchy light rain
            1183: 'rainy', // Light rain
            1186: 'rainy', // Moderate rain at times
            1189: 'rainy', // Moderate rain
            1192: 'rainy', // Heavy rain at times
            1195: 'rainy', // Heavy rain
            1198: 'rainy', // Light freezing rain
            1201: 'rainy', // Moderate or heavy freezing rain
            1204: 'storm', // Light sleet
            1207: 'storm', // Moderate or heavy sleet
            1210: 'storm', // Patchy light snow
            1213: 'storm', // Light snow
            1216: 'storm', // Patchy moderate snow
            1219: 'storm', // Moderate snow
            1222: 'storm', // Patchy heavy snow
            1225: 'storm', // Heavy snow
            1237: 'storm', // Ice pellets
            1240: 'rainy', // Light rain shower
            1243: 'rainy', // Moderate or heavy rain shower
            1246: 'storm', // Torrential rain shower
            1249: 'storm', // Light sleet showers
            1252: 'storm', // Moderate or heavy sleet showers
            1255: 'storm', // Light snow showers
            1258: 'storm', // Moderate or heavy snow showers
            1261: 'storm', // Light showers of ice pellets
            1264: 'storm', // Moderate or heavy showers of ice pellets
            1273: 'storm', // Patchy light rain with thunder
            1276: 'storm', // Moderate or heavy rain with thunder
            1279: 'storm', // Patchy light snow with thunder
            1282: 'storm', // Moderate or heavy snow with thunder
        };

        return conditionMap[code] || (isDay ? 'sunny' : 'clear-night');
    };

    // Weather animation sources - only Lottie animations
    const weatherAnimations = {
        'sunny': require('../../assets/animations/sunny.json'),
        'rainy': require('../../assets/animations/rainy.json'),
        'rainy-night': require('../../assets/animations/rainy-night.json'),
        'cloudy': require('../../assets/animations/clouds.json'),
        'clear-night': require('../../assets/animations/night.json'),
        'storm': require('../../assets/animations/storm.json'),
        'windy': require('../../assets/animations/windy.json')
    };

    // Get weather conditions based on time and random factors - only Lottie animations
    const getWeatherCondition = () => {
        const hour = new Date().getHours();
        const conditions = [];

        // Time-based conditions - only using available Lottie animations
        if (hour >= 6 && hour < 18) {
            // Day conditions
            conditions.push(
                { condition: 'sunny', lottie: weatherAnimations['sunny'], weight: 4 },
                { condition: 'cloudy', lottie: weatherAnimations['cloudy'], weight: 3 },
                { condition: 'rainy', lottie: weatherAnimations['rainy'], weight: 2 },
                { condition: 'windy', lottie: weatherAnimations['windy'], weight: 2 },
                { condition: 'storm', lottie: weatherAnimations['storm'], weight: 1 },
            );
        } else {
            // Night conditions
            conditions.push(
                { condition: 'clear-night', lottie: weatherAnimations['clear-night'], weight: 4 },
                { condition: 'cloudy', lottie: weatherAnimations['cloudy'], weight: 3 },
                { condition: 'rainy-night', lottie: weatherAnimations['rainy-night'], weight: 2 },
                { condition: 'storm', lottie: weatherAnimations['storm'], weight: 1 },
                { condition: 'windy', lottie: weatherAnimations['windy'], weight: 1 },
            );
        }

        // Weighted random selection
        const totalWeight = conditions.reduce((sum, c) => sum + c.weight, 0);
        let random = Math.random() * totalWeight;

        for (const condition of conditions) {
            random -= condition.weight;
            if (random <= 0) {
                return condition;
            }
        }

        return conditions[0]; // Fallback
    };

    // Animate weather icon change
    const animateWeatherChange = (newCondition) => {
        // Bounce and fade animation
        Animated.sequence([
            Animated.parallel([
                Animated.timing(weatherIconAnim, {
                    toValue: 0,
                    duration: 300,
                    useNativeDriver: true,
                }),
                Animated.timing(bounceAnim, {
                    toValue: 1.2,
                    duration: 200,
                    useNativeDriver: true,
                })
            ]),
            Animated.timing(bounceAnim, {
                toValue: 1,
                duration: 100,
                useNativeDriver: true,
            })
        ]).start(() => {
            setWeatherCondition(newCondition.condition);
            setCurrentLottieSource(newCondition.lottie);

            // Restart Lottie animation
            if (lottieRef.current) {
                lottieRef.current.reset();
                lottieRef.current.play();
            }

            Animated.timing(weatherIconAnim, {
                toValue: 1,
                duration: 400,
                useNativeDriver: true,
            }).start();
        });
    };

    const onLogout = async () => {
        setLoading(true);
        const result = await logout();
        if(result.success) {
            router.replace('/welcome');
        } else {
            Alert.alert('LogOut Error', result.error || 'Failed to log out. Please try again.');
        }
        setLoading(false);
    };

    const onProfilePress = () => {
        router.push("/profile");
    };




    return (
        <ScreenWrapper bg='white'>
            <StatusBar style="dark" />
            {/* Header Section */}
            <View style={[styles.header, styles.container]}>
                {/* Left side - Greeting */}
                <View style={styles.greetingContainer}>
                    {/* Background Autumn Plants Animation */}
                    <View style={styles.backgroundAnimationContainer}>
                        <LottieView
                            source={require('../../assets/animations/autumn-plants.json')}
                            style={styles.backgroundAnimation}
                            autoPlay
                            loop
                            speed={0.5}
                        />
                    </View>

                    <Animated.View
                        style={[
                            styles.greetingContainer,
                            {
                                opacity: fadeAnim,
                                transform: [{ translateY: moveUpAnim }],
                            },
                        ]}
                    >
                        <Text style={styles.greetingText} numberOfLines={1} ellipsizeMode="tail" allowFontScaling={false}>
                            {displayedText}
                            {/* blinking cursor: use opacity from cursorAnim */}
                            <Animated.Text style={{ opacity: cursorAnim }}>|</Animated.Text>
                        </Text>
                    </Animated.View>
                    <Text style={styles.dateText}>
                        {new Date().toLocaleDateString('en-US', {
                            weekday: 'long',
                            month: 'long',
                            day: 'numeric'
                        })}
                    </Text>
                </View>

                {/* Right side - Weather & Profile */}
                <View style={styles.headerActions}>
                    {/* Animated Weather Icon */}
                    <Animated.View style={[
                        styles.weatherContainer,
                        {
                            opacity: weatherIconAnim,
                            transform: [{ scale: bounceAnim }]
                        }
                    ]}>
                        {currentLottieSource && (
                            <LottieView
                                ref={lottieRef}
                                source={currentLottieSource}
                                style={styles.lottieWeather}
                                autoPlay
                                loop
                                speed={0.8}
                            />
                        )}
                    </Animated.View>

                    {/* Animated Profile Icon */}
                    <Pressable style={styles.profileButton} onPress={onProfilePress}>
                        <LottieView
                            source={require('../../assets/animations/user.json')}
                            autoPlay
                            loop
                            style={styles.lottieProfile}
                        />
                    </Pressable>
                </View>
            </View>
            <ScrollView contentContainerStyle={styles.container} showsVerticalScrollIndicator={false}>


                {/* Weather Section */}
                <View style={styles.weatherSection}>
                    {weatherLoading ? (
                        <View style={styles.loadingContainer}>
                            <LottieView
                                source={require('../../assets/animations/loading.json')}
                                style={styles.loadingAnimation}
                                autoPlay
                                loop
                                speed={1.5}
                            />
                            <Text style={styles.loadingText}>Loading weather...</Text>
                        </View>
                    ) : weatherData ? (
                        <View style={styles.weatherCard}>
                            <View style={styles.weatherHeader}>
                                <Text style={styles.locationText}>
                                    üìç {weatherData.location.name}, {weatherData.location.country}
                                </Text>
                                <Text style={styles.lastUpdated}>
                                    Updated: {new Date(weatherData.current.last_updated).toLocaleTimeString('en-US', {
                                    hour: '2-digit',
                                    minute: '2-digit'
                                })}
                                </Text>
                            </View>

                            <View style={styles.weatherMain}>
                                <View style={styles.temperatureContainer}>
                                    <Text style={styles.temperature}>
                                        {Math.round(weatherData.current.temp_c)}¬∞
                                    </Text>
                                    <View style={styles.temperatureDetails}>
                                        <Text style={styles.condition}>
                                            {weatherData.current.condition.text}
                                        </Text>
                                        <Text style={styles.feelsLike}>
                                            Feels like {Math.round(weatherData.current.feelslike_c)}¬∞C
                                        </Text>
                                    </View>
                                </View>

                                <View style={styles.weatherIcon}>
                                    {currentLottieSource && (
                                        <LottieView
                                            source={currentLottieSource}
                                            style={styles.weatherLottieIcon}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                    )}
                                </View>
                            </View>

                            <View style={styles.weatherDetails}>
                                <View style={styles.detailItem}>
                                    <View style={styles.detailIcon}>
                                        <LottieView
                                            source={require('../../assets/animations/clouds.json')}
                                            style={styles.detailLottie}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                    </View>
                                    <View style={styles.detailTextGroup}>
                                        <Text style={styles.detailLabel}>Humidity</Text>
                                        <Text style={styles.detailValue}>{weatherData.current.humidity}%</Text>
                                    </View>
                                </View>

                                <View style={styles.detailItem}>
                                    <View style={styles.detailIcon}>
                                        <LottieView
                                            source={require('../../assets/animations/windblow.json')}
                                            style={styles.detailLottie}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                    </View>
                                    <View style={styles.detailTextGroup}>
                                        <Text style={styles.detailLabel}>Wind</Text>
                                        <Text style={styles.detailValue}>{weatherData.current.wind_kph} km/h</Text>
                                    </View>
                                </View>

                                <View style={styles.detailItem}>
                                    <View style={styles.detailIcon}>
                                        <LottieView
                                            source={require('../../assets/animations/uv-index.json')}
                                            style={styles.detailLottie}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                    </View>
                                    <View style={styles.detailTextGroup}>
                                        <Text style={styles.detailLabel}>UV Index</Text>
                                        <Text style={styles.detailValue}>{weatherData.current.uv}</Text>
                                    </View>
                                </View>

                                <View style={styles.detailItem}>
                                    <View style={styles.detailIcon}>
                                        <LottieView
                                            source={require('../../assets/animations/sunny.json')}
                                            style={styles.detailLottie}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                    </View>
                                    <View style={styles.detailTextGroup}>
                                        <Text style={styles.detailLabel}>Visibility</Text>
                                        <Text style={styles.detailValue}>{weatherData.current.vis_km} km</Text>
                                    </View>
                                </View>
                            </View>
                        </View>
                    ) : (
                        <View style={styles.weatherError}>
                            <Text style={styles.errorText}>Unable to load weather data</Text>
                            <Pressable
                                style={styles.retryButton}
                                onPress={() => {
                                    if (location.latitude && location.longitude) {
                                        fetchWeatherData(location.latitude, location.longitude);
                                    } else {
                                        getUserLocation();
                                    }
                                }}
                            >
                                <Text style={styles.retryButtonText}>Retry</Text>
                            </Pressable>
                        </View>
                    )}
                </View>

                {/* IoT Sensors Section (single organized card) */}
                <View style={styles.iotSection}>
                    <Text style={styles.sectionTitle}>üå± Smart Farm Sensors</Text>

                    {iotLoading ? (
                        <View style={styles.loadingContainer}>
                            <LottieView
                                source={require('../../assets/animations/loading.json')}
                                style={styles.loadingAnimation}
                                autoPlay
                                loop
                                speed={1.5}
                            />
                            <Text style={styles.loadingText}>Loading sensor data...</Text>
                        </View>
                    ) : iotData ? (
                        <View style={styles.iotSingleCard}>
                            <View style={styles.iotSingleHeader}>
                                <Text style={styles.locationText}>üîó Farm Sensor Hub</Text>
                                <Text style={styles.lastUpdated}>
                                    Updated: {lastIotUpdate
                                        ? lastIotUpdate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                                        : 'Never'}
                                </Text>
                            </View>

                            <View style={styles.iotSingleBody}>
                                <View style={styles.iotRow}>
                                    <Animated.View style={[styles.rowLeft, { opacity: statusFadeAnim }]}>
                                        <LottieView
                                            source={isIotOnline
                                                ? require('../../assets/animations/connection.json')
                                                : require('../../assets/animations/offline.json')}
                                            style={styles.rowIcon}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                        <View style={styles.rowText}>
                                            <Text style={styles.iotLabel}>System Status</Text>
                                            <Text style={[styles.iotValue, { color: isIotOnline ? '#4CAF50' : '#F44336' }]}>
                                                {isIotOnline ? 'Online' : 'Offline'}
                                            </Text>
                                            <Text style={[styles.iotStatus, { color: isIotOnline ? '#757575' : '#F44336' }]}>
                                                {isIotOnline ? 'Connected' : 'Disconnected'}
                                            </Text>
                                        </View>
                                    </Animated.View>

                                    <View style={styles.rowRight}>
                                        <View style={styles.smallMetric}>
                                            <LottieView source={require('../../assets/animations/temperature.json')} style={styles.smallIcon} autoPlay loop speed={0.8} />
                                            <Text style={styles.smallLabel}>Temperature</Text>
                                            <Text style={[styles.smallValue, { color: iotService.getTemperatureStatus(iotData.temperature).color }]}>{iotService.formatTemperature(iotData.temperature)}</Text>
                                        </View>

                                        <View style={styles.smallMetric}>
                                            <LottieView source={require('../../assets/animations/clouds.json')} style={styles.smallIcon} autoPlay loop speed={0.8} />
                                            <Text style={styles.smallLabel}>Humidity</Text>
                                            <Text style={styles.smallValue}>{iotService.formatHumidity(iotData.humidity)}</Text>
                                        </View>

                                        <View style={styles.smallMetric}>
                                            <LottieView source={require('../../assets/animations/Seedling.json')} style={styles.smallIcon} autoPlay loop speed={0.8} />
                                            <Text style={styles.smallLabel}>Soil</Text>
                                            <Text style={styles.smallValue}>{iotService.formatSoilMoisture(iotData.soil)}</Text>
                                        </View>

                                        <View style={styles.smallMetric}>
                                            <LottieView
                                                source={iotData.light === 'Dark'
                                                    ? require('../../assets/animations/night.json')
                                                    : require('../../assets/animations/sunny.json')}
                                                style={styles.smallIcon}
                                                autoPlay
                                                loop
                                                speed={0.8}
                                            />
                                            <Text style={styles.smallLabel}>Source</Text>
                                            <Text style={styles.smallValue}>{iotService.formatLightLevel(iotData.light)}</Text>
                                        </View>
                                    </View>
                                </View>

                                <View style={styles.iotDivider} />

                                <View style={styles.iotRowBottom}>
                                    <View style={styles.bottomItem}>
                                        <LottieView
                                            source={!isIotOnline || iotService.getRainStatus(iotData.rain).status === 'Clear'
                                                ? require('../../assets/animations/sunny.json')
                                                : require('../../assets/animations/rainy.json')}
                                            style={styles.smallIcon}
                                            autoPlay
                                            loop
                                            speed={0.8}
                                        />
                                        <View style={{marginLeft: wp(3)}}>
                                            <Text style={styles.smallLabel}>Rain</Text>
                                            <Text style={[styles.smallValue, { color: isIotOnline ? iotService.getRainStatus(iotData.rain).color : '#999' }]}>
                                                {isIotOnline ? `${iotService.formatRainLevel(iotData.rain)} ¬∑ ${iotService.getRainStatus(iotData.rain).status}` : 'N/A ¬∑ Offline'}
                                            </Text>
                                        </View>
                                    </View>

                                    <Pressable
                                        style={styles.healthCheckButton}
                                        onPress={fetchHealthCheck}
                                        disabled={healthLoading}
                                    >
                                        {healthLoading ? (
                                            <ActivityIndicator size="small" color="#fff" />
                                        ) : (
                                            <Text style={styles.healthCheckButtonText}>Health Check</Text>
                                        )}
                                    </Pressable>
                                </View>

                                {/* Health Check Modal */}
                                {showHealthCheck && (
                                    <Animated.View
                                        style={[
                                            styles.healthCheckModal,
                                            {
                                                opacity: healthModalFadeAnim,
                                                transform: [{ scale: healthModalScaleAnim }]
                                            }
                                        ]}
                                    >
                                        <View style={styles.healthCheckHeader}>
                                            <Text style={styles.healthCheckTitle}>
                                                {healthLoading ? 'Analyzing Sensors...' : 'Device Health Status'}
                                            </Text>
                                            <Pressable onPress={() => {
                                                setShowHealthCheck(false);
                                                setHealthData(null);
                                            }}>
                                                <Text style={styles.healthCheckClose}>‚úï</Text>
                                            </Pressable>
                                        </View>

                                        {healthLoading ? (
                                            <View style={styles.healthCheckLoading}>
                                                <LottieView
                                                    source={require('../../assets/animations/health-heart.json')}
                                                    style={styles.healthHeartAnimation}
                                                    autoPlay
                                                    loop
                                                    speed={1}
                                                />
                                                <Text style={styles.checkingText}>Checking Sensors</Text>
                                                <View style={styles.sensorCheckList}>
                                                    <Text style={styles.sensorCheckItem}>‚Ä¢ Temperature Sensor</Text>
                                                    <Text style={styles.sensorCheckItem}>‚Ä¢ Humidity Sensor</Text>
                                                    <Text style={styles.sensorCheckItem}>‚Ä¢ Soil Moisture Sensor</Text>
                                                    <Text style={styles.sensorCheckItem}>‚Ä¢ Light Sensor</Text>
                                                    <Text style={styles.sensorCheckItem}>‚Ä¢ Rain Sensor</Text>
                                                </View>
                                            </View>
                                        ) : healthData ? (
                                            <>
                                                {/* Overall Status */}
                                                <View style={styles.overallStatus}>
                                                    <Text style={styles.overallStatusLabel}>Overall System:</Text>
                                                    <Text style={[styles.overallStatusValue, { color: isIotOnline ? '#4CAF50' : '#F44336' }]}>
                                                        {healthData.overall}
                                                    </Text>
                                                </View>

                                                <View style={styles.healthCheckContent}>
                                                    <View style={styles.healthItem}>
                                                        <Text style={styles.healthLabel}>Temperature Sensor:</Text>
                                                        <Text style={[styles.healthStatus, {
                                                            color: healthData.temperature.includes('OK') ? '#4CAF50' :
                                                                   healthData.temperature.includes('WARNING') ? '#FF9800' : '#F44336'
                                                        }]}>
                                                            {healthData.temperature}
                                                        </Text>
                                                    </View>
                                                    <View style={styles.healthItem}>
                                                        <Text style={styles.healthLabel}>Humidity Sensor:</Text>
                                                        <Text style={[styles.healthStatus, {
                                                            color: healthData.humidity.includes('OK') ? '#4CAF50' :
                                                                   healthData.humidity.includes('WARNING') ? '#FF9800' : '#F44336'
                                                        }]}>
                                                            {healthData.humidity}
                                                        </Text>
                                                    </View>
                                                    <View style={styles.healthItem}>
                                                        <Text style={styles.healthLabel}>Soil Moisture Sensor:</Text>
                                                        <Text style={[styles.healthStatus, {
                                                            color: healthData.soil.includes('OK') ? '#4CAF50' :
                                                                   healthData.soil.includes('WARNING') ? '#FF9800' : '#F44336'
                                                        }]}>
                                                            {healthData.soil}
                                                        </Text>
                                                    </View>
                                                    <View style={styles.healthItem}>
                                                        <Text style={styles.healthLabel}>Light Sensor:</Text>
                                                        <Text style={[styles.healthStatus, {
                                                            color: healthData.light.includes('OK') ? '#4CAF50' :
                                                                   healthData.light.includes('WARNING') ? '#FF9800' : '#F44336'
                                                        }]}>
                                                            {healthData.light}
                                                        </Text>
                                                    </View>
                                                    <View style={styles.healthItem}>
                                                        <Text style={styles.healthLabel}>Rain Sensor:</Text>
                                                        <Text style={[styles.healthStatus, {
                                                            color: healthData.rain.includes('OK') ? '#4CAF50' :
                                                                   healthData.rain.includes('WARNING') ? '#FF9800' : '#F44336'
                                                        }]}>
                                                            {healthData.rain}
                                                        </Text>
                                                    </View>
                                                </View>
                                            </>
                                        ) : null}
                                    </Animated.View>
                                )}
                            </View>
                        </View>
                    ) : (
                        <View style={styles.iotError}>
                            <Text style={styles.errorText}>Unable to load sensor data</Text>
                            <Pressable style={styles.retryButton} onPress={fetchIoTData}><Text style={styles.retryButtonText}>Retry</Text></Pressable>
                        </View>
                    )}
                </View>

                {/* Main Content Area */}
                {/* spacer so user can scroll past IoT card */}
                <View style={styles.bottomSpacer} />
                <View style={styles.content}>
                    {/* Content will be added here */}
                </View>

                {/*/!* Temporary logout button - will be moved to profile later *!/*/}
                {/*<View style={styles.footer}>*/}
                {/*    <Button loading={loading} title={'Log Out'} onPress={onLogout} />*/}
                {/*</View>*/}
            </ScrollView>
        </ScreenWrapper>
    )
}
export default Home
const styles = StyleSheet.create({
    container: {
        flexGrow: 1,
        paddingHorizontal: wp(5),
        // paddingTop: hp(2),
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        paddingVertical: hp(2),
        paddingBottom: hp(3),
    },
    // greetingContainer: {
    //     flex: 1,
    //     overflow: 'visible', // Changed to visible to show Hindi characters properly
    //     paddingVertical: hp(1), // More padding for better animation visibility
    //     paddingHorizontal: wp(2), // Add horizontal padding
    //     position: 'relative', // Enable positioning for background animation
    //     minHeight: hp(8), // Ensure enough height for the animation
    // },
    backgroundAnimationContainer: {
        position: 'absolute',
        top: -hp(1),
        left: -wp(8), // Extended more to the left
        right: -wp(15), // Extended to the right
        bottom: -hp(1),
        zIndex: 0,
        opacity: 0.4, // Slightly more visible
        justifyContent: 'center',
        alignItems: 'flex-start',
    },
    backgroundAnimation: {
        width: wp(55), // Much wider to span left to right
        height: hp(10), // Slightly taller
        opacity: 0.7,
    },
    animatedTextContainer: {
        minHeight: hp(4), // Ensure container has enough height for Hindi characters
        justifyContent: 'center',
        zIndex: 2, // Ensure text appears above background animation
        position: 'relative',
        paddingVertical: hp(0.5),
        marginLeft: wp(1), // Slight left margin for better positioning
    },
    // greetingText: {
    //     fontSize: hp(2.8),
    //     fontFamily: 'SFNSDisplay-Bold',
    //     color: theme.colors.textDark,
    //     lineHeight: hp(3.8), // Increased line height for better Hindi character spacing
    //     includeFontPadding: false, // Remove extra font padding that can clip text
    //     textAlignVertical: 'center', // Center text vertically
    // },
    cursor: {
        fontSize: hp(2.8),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.primary,
        opacity: 0.7,
    },
    dateText: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
        marginTop: hp(0.5),
        marginLeft: wp(1), // Align with greeting text
        zIndex: 2,
        position: 'relative',
    },
    headerActions: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: wp(3),
    },
    weatherContainer: {
        width: wp(12),
        height: wp(12),
        borderRadius: wp(6),
        backgroundColor: 'rgba(80, 200, 120, 0.1)',
        justifyContent: 'center',
        alignItems: 'center',
        borderWidth: 1,
        borderColor: 'rgba(80, 200, 120, 0.2)',
    },

    lottieWeather: {
        width: wp(10),
        height: wp(10),
    },
    lottieProfile: {
        width: wp(8),
        height: wp(8),
    },
    profileButton: {
        width: wp(12),
        height: wp(12),
        borderRadius: wp(6),
        backgroundColor: theme.colors.gray,
        justifyContent: 'center',
        alignItems: 'center',
        shadowColor: theme.colors.dark,
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
        elevation: 3,
    },
    weatherSection: {
        paddingHorizontal: wp(2),
        paddingBottom: hp(2),
    },
    loadingContainer: {
        backgroundColor: 'rgba(255, 255, 255, 0.9)',
        borderRadius: 20,
        padding: wp(6),
        alignItems: 'center',
        justifyContent: 'center',
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 5,
        minHeight: hp(20),
    },
    loadingText: {
        fontSize: hp(1.8),
        fontFamily: 'SFNSText-Medium',
        color: theme.colors.textLight,
        marginTop: hp(1),
    },
    loadingAnimation: {
        width: wp(20),
        height: wp(20),
    },
    weatherCard: {
        backgroundColor: 'rgba(255, 255, 255, 0.95)',
        borderRadius: 20,
        padding: wp(5),
        shadowColor: 'rgb(2,57,18)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 10,
        borderWidth: 1,
        borderColor: 'rgba(80, 200, 120, 0.1)',
        marginTop: 8,
    },
    weatherHeader: {
        marginBottom: hp(2),
    },
    locationText: {
        fontSize: hp(1.9),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
        marginBottom: hp(0.5),
    },
    lastUpdated: {
        fontSize: hp(1.4),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
    },
    weatherMain: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: hp(2.5),
    },
    temperatureContainer: {
        flex: 1,
    },
    temperature: {
        fontSize: hp(7),
        fontFamily: 'SFNSDisplay-Heavy',
        color: theme.colors.primary,
        lineHeight: hp(7),
        marginBottom: hp(0.5),
    },
    temperatureDetails: {
        gap: hp(0.3),
    },
    condition: {
        fontSize: hp(2),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
        textTransform: 'capitalize',
    },
    feelsLike: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
    },
    weatherIcon: {
        width: wp(20),
        height: wp(20),
        justifyContent: 'center',
        alignItems: 'center',
    },
    weatherLottieIcon: {
        width: wp(18),
        height: wp(18),
    },
    weatherDetails: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        flexWrap: 'wrap',
        gap: hp(1),
        paddingTop: hp(2),
        paddingHorizontal: wp(1),
        borderTopWidth: 1,
        borderTopColor: 'rgba(0, 0, 0, 0.05)',
    },
    detailItem: {
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        minWidth: wp(20),
        maxWidth: wp(22),
        paddingVertical: hp(0.8),
        paddingHorizontal: wp(1),
    },
    detailIcon: {
        width: wp(10),
        height: wp(10),
        justifyContent: 'center',
        alignItems: 'center',
        marginBottom: hp(0.3),
    },
    detailLottie: {
        width: wp(8),
        height: wp(8),
    },
    detailTextGroup: {
        justifyContent: 'center',
        alignItems: 'center',
        gap: hp(0.1),
    },
    detailLabel: {
        fontSize: hp(1.4),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
        marginBottom: hp(0.3),
    },
    detailValue: {
        fontSize: hp(1.7),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
    },
    weatherError: {
        backgroundColor: 'rgba(255, 255, 255, 0.9)',
        borderRadius: 20,
        padding: wp(6),
        alignItems: 'center',
        justifyContent: 'center',
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 5,
        minHeight: hp(15),
    },
    // IoT Summary Card (styled like weather card)
    iotSummaryCard: {
        backgroundColor: 'rgba(255, 255, 255, 0.98)',
        borderRadius: 18,
        padding: wp(4),
        borderWidth: 1,
        borderColor: 'rgba(80, 200, 120, 0.08)',
        marginBottom: hp(1.5),
        shadowColor: 'rgb(2,57,18)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 10,
    },
    iotSummaryHeader: {
        marginBottom: hp(1.2),
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    iotSummaryMain: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    iotSummaryPrimary: {
        flex: 1,
        paddingRight: wp(3),
    },
    summaryDetailItem: {
        alignItems: 'center',
        marginBottom: hp(0.4),
    },
    iotSummaryDetails: {
        width: wp(40),
        flexDirection: 'column',
        justifyContent: 'center',
    },
    errorText: {
        fontSize: hp(1.8),
        fontFamily: 'SFNSText-Medium',
        color: theme.colors.textLight,
        marginBottom: hp(2),
        textAlign: 'center',
    },
    retryButton: {
        backgroundColor: theme.colors.primary,
        paddingHorizontal: wp(6),
        paddingVertical: hp(1.2),
        borderRadius: 12,
    },
    retryButtonText: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSDisplay-Bold',
        color: 'white',
    },
    content: {
        flex: 1,
        paddingVertical: hp(2),
    },
    footer: {
        paddingBottom: hp(4),
    },
    greetingContainer: {
        minHeight: 28,        // reserve height (adjust to your font-size/line-height)
        justifyContent: 'center',
        overflow: 'hidden',   // prevents visual jump
    },
    greetingText: {
        fontSize: 18,         // match your actual font-size
        lineHeight: 22,
        fontFamily: 'SFNSDisplay-Bold',// set lineHeight to a fixed value

    },
    // IoT Section Styles
    iotSection: {
        paddingHorizontal: wp(2),
        paddingBottom: hp(3),
        marginTop: 20
    },
    sectionTitle: {
        fontSize: hp(2.2),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
        marginBottom: hp(2),
        textAlign: 'center',
    },
    iotGrid: {
        flexDirection: 'row',
        flexWrap: 'wrap',
        justifyContent: 'space-between',
        gap: hp(1.5),
    },
    iotCard: {
        backgroundColor: 'rgba(255, 255, 255, 0.95)',
        borderRadius: 16,
        padding: wp(4),
        flexDirection: 'row',
        alignItems: 'center',
        width: wp(42),
        minHeight: hp(12),
        borderWidth: 1,
        borderColor: 'rgba(80, 200, 120, 0.1)',
        shadowColor: 'rgb(2,57,18)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 10,
    },
    deviceStatusCard: {
        width: wp(88),
        flexDirection: 'row',
        justifyContent: 'center',
    },
    iotIconContainer: {
        width: wp(12),
        height: wp(12),
        borderRadius: wp(6),
        backgroundColor: 'rgba(80, 200, 120, 0.1)',
        justifyContent: 'center',
        alignItems: 'center',
        marginRight: wp(3),
    },
    iotIcon: {
        width: wp(10),
        height: wp(10),
    },
    iotContent: {
        flex: 1,
        justifyContent: 'center',
    },
    iotLabel: {
        fontSize: hp(1.4),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
        marginBottom: hp(0.3),
    },
    iotValue: {
        fontSize: hp(2.2),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
        marginBottom: hp(0.2),
    },
    iotStatus: {
        fontSize: hp(1.3),
        fontFamily: 'SFNSText-Medium',
        color: theme.colors.textLight,
    },
    iotError: {
        backgroundColor: 'rgba(255, 255, 255, 0.9)',
        borderRadius: 20,
        padding: wp(6),
        alignItems: 'center',
        justifyContent: 'center',
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 5,
        minHeight: hp(15),
    },
    // Single organized IoT card styles
    iotSingleCard: {
        backgroundColor: 'rgba(255,255,255,0.98)',
        borderRadius: 18,
        padding: wp(4),
        borderWidth: 1,
        borderColor: 'rgba(80,200,120,0.08)',
        marginBottom: hp(2),
        shadowColor: 'rgb(2,57,18)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 10,
    },
    iotSingleHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: hp(1),
    },
    iotSingleBody: {
        // main body
    },
    iotRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    rowLeft: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
    },
    rowRight: {
        width: wp(36),
        flexDirection: 'column',
        justifyContent: 'space-between',
        alignItems: 'flex-end',
    },
    rowIcon: {
        width: wp(24),
        height: wp(24),
        marginRight: wp(3),
    },
    rowText: {
        justifyContent: 'center',
    },
    smallMetric: {
        alignItems: 'center',
        marginBottom: hp(0.6),
    },
    smallIcon: {
        width: wp(8),
        height: wp(8),
    },
    smallLabel: {
        fontSize: hp(1.2),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
    },
    smallValue: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
    },
    iotDivider: {
        height: 1,
        backgroundColor: 'rgba(0,0,0,0.04)',
        marginVertical: hp(1.2),
    },
    iotRowBottom: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    bottomItem: {
        flexDirection: 'row',
        alignItems: 'center',
        flex: 1,
    },
    bottomSpacer: {
        height: hp(10),
    },
    healthCheckButton: {
        backgroundColor: theme.colors.primary,
        paddingHorizontal: wp(4),
        paddingVertical: hp(1),
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
        minWidth: wp(25),
    },
    healthCheckButtonText: {
        fontSize: hp(1.4),
        fontFamily: 'SFNSDisplay-Bold',
        color: 'white',
    },
    healthCheckModal: {
        backgroundColor: 'rgba(255, 255, 255, 0.98)',
        borderRadius: 16,
        padding: wp(4),
        marginTop: hp(2),
        borderWidth: 1,
        borderColor: 'rgba(80, 200, 120, 0.2)',
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 1,
        shadowRadius: 12,
        elevation: 5,
    },
    healthCheckHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: hp(1.5),
        paddingBottom: hp(1),
        borderBottomWidth: 1,
        borderBottomColor: 'rgba(0, 0, 0, 0.05)',
    },
    healthCheckTitle: {
        fontSize: hp(2),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
    },
    healthCheckClose: {
        fontSize: hp(2.5),
        color: theme.colors.textLight,
        fontFamily: 'SFNSDisplay-Bold',
    },
    overallStatus: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        backgroundColor: 'rgba(80, 200, 120, 0.1)',
        padding: wp(3),
        borderRadius: 12,
        marginBottom: hp(1.5),
    },
    overallStatusLabel: {
        fontSize: hp(1.8),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.textDark,
    },
    overallStatusValue: {
        fontSize: hp(1.8),
        fontFamily: 'SFNSDisplay-Bold',
    },
    healthCheckContent: {
        gap: hp(1),
    },
    healthItem: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: hp(0.8),
    },
    healthLabel: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textDark,
    },
    healthStatus: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSDisplay-Bold',
    },
    healthCheckLoading: {
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: hp(3),
    },
    healthHeartAnimation: {
        width: wp(40),
        height: wp(40),
    },
    checkingText: {
        fontSize: hp(2),
        fontFamily: 'SFNSDisplay-Bold',
        color: theme.colors.primary,
        marginTop: hp(2),
        marginBottom: hp(1.5),
    },
    sensorCheckList: {
        alignItems: 'flex-start',
        gap: hp(0.8),
    },
    sensorCheckItem: {
        fontSize: hp(1.6),
        fontFamily: 'SFNSText-Regular',
        color: theme.colors.textLight,
    },
})


app/(tabs)/recommendation.jsx:
import { Ionicons } from '@expo/vector-icons';
import { StatusBar } from "expo-status-bar";
import LottieView from 'lottie-react-native';
import { useEffect, useState } from 'react';
import {
    FlatList,
    Pressable,
    RefreshControl,
    StyleSheet,
    Text,
    TextInput,
    View
} from 'react-native';
import { SafeAreaView } from "react-native-safe-area-context";
import { theme } from "../../constants/theme";
import { hp, wp } from "../../helpers/common";
import { marketPriceService } from "../../services/marketPriceService";

const Recommendation = () => {
    const [marketData, setMarketData] = useState([]);
    const [searchResults, setSearchResults] = useState([]); // New state for search results
    const [loading, setLoading] = useState(true);
    const [searchLoading, setSearchLoading] = useState(false); // New loading state for search
    const [refreshing, setRefreshing] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [selectedCommodity, setSelectedCommodity] = useState('');
    const [commodities, setCommodities] = useState([]);
    const [isSearchMode, setIsSearchMode] = useState(false); // New state to track if we're in search mode

    useEffect(() => {
        fetchMarketData();
        fetchCommodities();
    }, []);

    // Debounced search effect for real-time search
    useEffect(() => {
        if (searchQuery.trim().length === 0) {
            setIsSearchMode(false);
            setSearchResults([]);
            return;
        }

        const debounceTimer = setTimeout(() => {
            performRealTimeSearch(searchQuery);
        }, 500); // 500ms delay for debouncing

        return () => clearTimeout(debounceTimer);
    }, [searchQuery]);

    const fetchMarketData = async () => {
        try {
            setLoading(true);

            const result = await marketPriceService.getMarketPrices({
                limit: 50,
                commodity: selectedCommodity
            });

            if (result.success) {
                const formattedData = result.data.map(record =>
                    marketPriceService.formatPriceData(record)
                );
                setMarketData(formattedData);
            } else {
                console.error('‚ùå Failed to fetch market data:', result.error);
            }
        } catch (error) {
            console.error('üí• Error fetching market data:', error);
        } finally {
            setLoading(false);
        }
    };



    const fetchCommodities = async () => {
        try {
            const result = await marketPriceService.getCommodities();
            if (result.success) {
                setCommodities(result.data.slice(0, 10)); // Get first 10 commodities
            }
        } catch (error) {
            console.error('Error fetching commodities:', error);
        }
    };

    // New function for real-time search
    const performRealTimeSearch = async (query) => {
        if (!query || query.trim().length < 2) {
            setIsSearchMode(false);
            setSearchResults([]);
            return;
        }

        try {
            setSearchLoading(true);
            setIsSearchMode(true);

            // Try searching by different parameters
            const searchPromises = [];

            // Search by state (try both exact match and partial)
            searchPromises.push(
                marketPriceService.getMarketPrices({
                    state: query,
                    limit: 100
                })
            );

            // Search by district
            searchPromises.push(
                marketPriceService.getMarketPrices({
                    district: query,
                    limit: 100
                })
            );

            // Search by market
            searchPromises.push(
                marketPriceService.getMarketPrices({
                    market: query,
                    limit: 100
                })
            );

            // Search by commodity
            searchPromises.push(
                marketPriceService.getMarketPrices({
                    commodity: query,
                    limit: 100
                })
            );

            const results = await Promise.all(searchPromises);

            // Combine all results and remove duplicates
            const allResults = [];
            const seenIds = new Set();

            results.forEach(result => {
                if (result.success && result.data) {
                    result.data.forEach(record => {
                        const id = `${record.state}-${record.district}-${record.market}-${record.commodity}-${record.variety}-${record.arrival_date}-${record.min_price}-${record.max_price}`;
                        if (!seenIds.has(id)) {
                            seenIds.add(id);
                            allResults.push(marketPriceService.formatPriceData(record));
                        }
                    });
                }
            });

            setSearchResults(allResults);

        } catch (error) {
            console.error('üí• Error in real-time search:', error);
            setSearchResults([]);
        } finally {
            setSearchLoading(false);
        }
    };

    const onRefresh = async () => {
        setRefreshing(true);
        // Clear search and filters on refresh
        setSearchQuery('');
        setSelectedCommodity('');
        setIsSearchMode(false);
        setSearchResults([]);

        await fetchMarketData();
        setRefreshing(false);
    };

    const filterData = () => {
        // If we're in search mode, use search results instead of filtering static data
        if (isSearchMode && searchQuery.trim().length >= 2) {
            let filteredData = searchResults;

            // Apply commodity filter to search results if needed
            if (selectedCommodity && selectedCommodity.trim()) {
                filteredData = searchResults.filter(item =>
                    item.commodity && item.commodity.toLowerCase().includes(selectedCommodity.toLowerCase())
                );
            }

            return filteredData;
        }

        // Original filtering logic for when not in search mode - only market data now
        let filteredData = marketData;

        // Apply commodity filter to static data
        if (selectedCommodity && selectedCommodity.trim()) {
            filteredData = filteredData.filter(item =>
                item.commodity && item.commodity.toLowerCase().includes(selectedCommodity.toLowerCase())
            );
        }

        return filteredData;
    };

    const handleCommodityFilter = async (commodity) => {
        if (selectedCommodity === commodity) {
            // If same commodity is selected, clear the filter
            setSelectedCommodity('');
            return;
        }

        setSelectedCommodity(commodity);

        // Fetch filtered data
        setLoading(true);

        const result = await marketPriceService.getMarketPrices({
            limit: 100,
            commodity: commodity
        });

        if (result.success) {
            const formattedData = result.data.map(record =>
                marketPriceService.formatPriceData(record)
            );
            setMarketData(formattedData);
        }
        setLoading(false);
    };

    const renderMarketItem = ({ item }) => (
        <View style={styles.marketCard}>
            <View style={styles.cardHeader}>
                <View style={styles.commodityInfo}>
                    <Text style={styles.commodityName}>{item.commodity}</Text>
                    <Text style={styles.varietyText}>{item.variety}</Text>
                </View>
                <View style={styles.priceContainer}>
                    <Text style={styles.modalPrice}>{item.modalPrice}</Text>
                    <Text style={styles.priceUnit}>per {item.priceUnit}</Text>
                </View>
            </View>

            <View style={styles.locationContainer}>
                <Ionicons name="location-outline" size={16} color={theme.colors.textLight} />
                <Text style={styles.locationText}>
                    {item.market}, {item.district}, {item.state}
                </Text>
            </View>

            <View style={styles.priceRange}>
                <View style={styles.priceRangeItem}>
                    <Text style={styles.priceLabel}>Min Price</Text>
                    <Text style={styles.minPrice}>{item.minPrice}</Text>
                </View>
                <View style={styles.priceRangeItem}>
                    <Text style={styles.priceLabel}>Max Price</Text>
                    <Text style={styles.maxPrice}>{item.maxPrice}</Text>
                </View>
                <View style={styles.priceRangeItem}>
                    <Text style={styles.priceLabel}>Date</Text>
                    <Text style={styles.dateText}>{item.arrivalDate}</Text>
                </View>
            </View>
        </View>
    );

    const renderCommodityFilter = ({ item }) => (
        <Pressable
            style={[
                styles.commodityChip,
                selectedCommodity === item && styles.commodityChipSelected
            ]}
            onPress={() => handleCommodityFilter(item)}
        >
            <Text style={[
                styles.commodityChipText,
                selectedCommodity === item && styles.commodityChipTextSelected
            ]}>
                {item}
            </Text>
        </Pressable>
    );

    return (
        <SafeAreaView style={styles.container}>
            <StatusBar style="dark" />

            {/* Header */}
            <View style={styles.header}>
                <View style={styles.headerLeft}>
                    <LottieView
                        source={require('../../assets/animations/nature.json')}
                        style={styles.headerIcon}
                        autoPlay
                        loop
                        speed={0.8}
                    />
                    <View>
                        <Text style={styles.headerTitle}>Market Prices</Text>
                        <Text style={styles.headerSubtitle}>Live crop market rates</Text>
                    </View>
                </View>
            </View>









            {/* Search Bar */}
            <View style={styles.searchContainer}>
                <Ionicons name="search-outline" size={20} color={theme.colors.textLight} />
                <TextInput
                    style={styles.searchInput}
                    placeholder="Search crops, states, districts..."
                    value={searchQuery}
                    onChangeText={setSearchQuery}
                    placeholderTextColor={theme.colors.textLight}
                />
                {searchQuery ? (
                    <Pressable onPress={() => setSearchQuery('')}>
                        <Ionicons name="close-circle" size={20} color={theme.colors.textLight} />
                    </Pressable>
                ) : null}
            </View>

            {/* Results Counter */}
            {(searchQuery || selectedCommodity || isSearchMode) && !searchLoading && (
                <View style={styles.resultsContainer}>
                    <Text style={styles.resultsText}>
                        {filterData().length} results found
                        {isSearchMode && searchQuery && ` for "${searchQuery}"`}
                        {!isSearchMode && searchQuery && ` for "${searchQuery}"`}
                        {selectedCommodity && ` in ${selectedCommodity}`}
                        {isSearchMode && ` (live search)`}
                    </Text>
                </View>
            )}

            {/* Commodity Filters */}
            <View style={styles.filtersSection}>
                <Text style={styles.filtersTitle}>Filter by Commodity</Text>
                <FlatList
                    data={['', ...commodities]} // Empty string for "All" option
                    renderItem={({ item }) => (
                        <Pressable
                            style={[
                                styles.commodityChip,
                                selectedCommodity === item && styles.commodityChipSelected
                            ]}
                            onPress={() => handleCommodityFilter(item)}
                        >
                            <Text style={[
                                styles.commodityChipText,
                                selectedCommodity === item && styles.commodityChipTextSelected
                            ]}>
                                {item || 'All'}
                            </Text>
                        </Pressable>
                    )}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={styles.commodityFilters}
                />
            </View>

            {/* Market Data List */}
            {searchLoading || (isSearchMode ? false : loading) ? (
                <View style={styles.loadingContainer}>
                    <LottieView
                        source={require('../../assets/animations/loading.json')}
                        style={styles.loadingAnimation}
                        autoPlay
                        loop
                        speed={1.5}
                    />
                    <Text style={styles.loadingText}>
                        {searchLoading
                            ? `Searching for "${searchQuery}"...`
                            : `Loading market prices...`
                        }
                    </Text>
                </View>
            ) : (
                <FlatList
                    data={filterData()}
                    renderItem={renderMarketItem}
                    keyExtractor={(item, index) => `${item.state}-${item.district}-${item.market}-${item.commodity}-${item.arrivalDate}-${index}`}
                    contentContainerStyle={styles.listContainer}
                    refreshControl={
                        <RefreshControl
                            refreshing={refreshing}
                            onRefresh={onRefresh}
                            colors={[theme.colors.primary]}
                        />
                    }
                    ListEmptyComponent={
                        <View style={styles.emptyContainer}>
                            <LottieView
                                source={require('../../assets/animations/nature.json')}
                                style={styles.emptyAnimation}
                                autoPlay
                                loop
                                speed={0.5}
                            />
                            <Text style={styles.emptyText}>
                                {searchQuery || selectedCommodity ? 'No results found' : 'No market data available'}
                            </Text>
                            <Text style={styles.emptySubtext}>
                                {searchQuery || selectedCommodity
                                    ? `Try a different search term or clear filters`
                                    : 'Pull down to refresh or try changing location'}
                            </Text>
                            {(searchQuery || selectedCommodity) && (
                                <Pressable
                                    style={styles.clearFiltersButton}
                                    onPress={() => {
                                        setSearchQuery('');
                                        setSelectedCommodity('');
                                    }}
                                >
                                    <Text style={styles.clearFiltersText}>Clear Filters</Text>
                                </Pressable>
                            )}
                        </View>
                    }
                    showsVerticalScrollIndicator={false}
                />
            )}
        </SafeAreaView>
    );
};

export default Recommendation;

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#f8f9fa',
    },
    header: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: wp(5),
        paddingVertical: hp(2),
        backgroundColor: 'white',
        borderBottomWidth: 1,
        borderBottomColor: '#f0f0f0',
    },
    headerLeft: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    headerIcon: {
        width: wp(12),
        height: wp(12),
        marginRight: wp(3),
    },
    headerTitle: {
        fontSize: hp(2.5),
        fontWeight: '700',
        color: theme.colors.textDark,
    },
    headerSubtitle: {
        fontSize: hp(1.4),
        color: theme.colors.textLight,
        marginTop: 2,
    },


    searchContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        backgroundColor: 'white',
        marginHorizontal: wp(5),
        marginVertical: hp(1.5),
        paddingHorizontal: wp(4),
        paddingVertical: hp(1.2),
        borderRadius: 12,
        borderWidth: 1,
        borderColor: '#e0e0e0',
    },
    searchInput: {
        flex: 1,
        marginLeft: wp(2),
        fontSize: hp(1.8),
        color: theme.colors.textDark,
    },
    filtersSection: {
        backgroundColor: 'white',
        paddingVertical: hp(1.5),
        borderBottomWidth: 1,
        borderBottomColor: '#f0f0f0',
    },
    filtersTitle: {
        fontSize: hp(1.6),
        fontWeight: '600',
        color: theme.colors.textDark,
        marginLeft: wp(5),
        marginBottom: hp(1),
    },
    commodityFilters: {
        paddingHorizontal: wp(5),
    },
    commodityChip: {
        backgroundColor: '#f0f0f0',
        paddingHorizontal: wp(3),
        paddingVertical: hp(0.8),
        borderRadius: 20,
        marginRight: wp(2),
    },
    commodityChipSelected: {
        backgroundColor: theme.colors.primary,
    },
    commodityChipText: {
        fontSize: hp(1.4),
        color: theme.colors.textDark,
        fontWeight: '500',
    },
    commodityChipTextSelected: {
        color: 'white',
    },
    listContainer: {
        padding: wp(5),
    },
    marketCard: {
        backgroundColor: 'white',
        borderRadius: 16,
        padding: wp(4),
        marginBottom: hp(2),
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
        elevation: 3,
    },
    cardHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        marginBottom: hp(1.5),
    },
    commodityInfo: {
        flex: 1,
    },
    commodityName: {
        fontSize: hp(2),
        fontWeight: '700',
        color: theme.colors.textDark,
        marginBottom: 4,
    },
    varietyText: {
        fontSize: hp(1.4),
        color: theme.colors.textLight,
    },
    priceContainer: {
        alignItems: 'flex-end',
    },
    modalPrice: {
        fontSize: hp(2.2),
        fontWeight: '700',
        color: theme.colors.primary,
    },
    priceUnit: {
        fontSize: hp(1.2),
        color: theme.colors.textLight,
        marginTop: 2,
    },
    locationContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: hp(1.5),
    },
    locationText: {
        fontSize: hp(1.4),
        color: theme.colors.textLight,
        marginLeft: wp(1),
        flex: 1,
    },
    priceRange: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        paddingTop: hp(1.5),
        borderTopWidth: 1,
        borderTopColor: '#f0f0f0',
    },
    priceRangeItem: {
        alignItems: 'center',
        flex: 1,
    },
    priceLabel: {
        fontSize: hp(1.2),
        color: theme.colors.textLight,
        marginBottom: 4,
    },
    minPrice: {
        fontSize: hp(1.6),
        fontWeight: '600',
        color: '#ff6b6b',
    },
    maxPrice: {
        fontSize: hp(1.6),
        fontWeight: '600',
        color: '#51cf66',
    },
    dateText: {
        fontSize: hp(1.4),
        fontWeight: '500',
        color: theme.colors.textDark,
    },
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        paddingVertical: hp(10),
    },
    loadingAnimation: {
        width: wp(20),
        height: wp(20),
    },
    loadingText: {
        fontSize: hp(1.8),
        color: theme.colors.textLight,
        marginTop: hp(2),
    },
    emptyContainer: {
        alignItems: 'center',
        paddingVertical: hp(10),
    },
    emptyAnimation: {
        width: wp(40),
        height: wp(40),
    },
    emptyText: {
        fontSize: hp(2),
        fontWeight: '600',
        color: theme.colors.textDark,
        marginTop: hp(2),
    },
    emptySubtext: {
        fontSize: hp(1.6),
        color: theme.colors.textLight,
        marginTop: hp(1),
        textAlign: 'center',
    },


    clearFiltersButton: {
        backgroundColor: theme.colors.primary,
        paddingHorizontal: wp(6),
        paddingVertical: hp(1.5),
        borderRadius: wp(6),
        marginTop: hp(2),
    },
    clearFiltersText: {
        color: 'white',
        fontSize: hp(1.6),
        fontWeight: '600',
    },
    resultsContainer: {
        paddingHorizontal: wp(4),
        paddingVertical: hp(1),
        backgroundColor: '#f0f8ff',
        borderLeftWidth: 3,
        borderLeftColor: theme.colors.primary,
    },
    resultsText: {
        fontSize: hp(1.4),
        color: theme.colors.textLight,
        fontStyle: 'italic',
    },

});


app/(tabs)/_layout.jsx:
import { Ionicons } from "@expo/vector-icons";
import { Tabs } from "expo-router";
import { Platform, StyleSheet, View } from "react-native";

const COLORS = {
    primary: '#22C55E', // Vibrant green
    primaryDark: '#16A34A',
    background: '#FFFFFF',
    inactive: '#94A3B8',
    activeBackground: '#DCFCE7', // Light green background
    shadow: '#000000',
    border: '#F1F5F9',
};

// Enhanced Tab Bar Icon Component
const TabBarIcon = ({ name, color, focused }) => {
    return (
        <View style={[
            styles.iconWrapper,
            focused && styles.iconWrapperActive
        ]}>
            <View style={[
                styles.iconContainer,
                focused && styles.iconContainerActive
            ]}>
                <Ionicons
                    name={name}
                    size={focused ? 28 : 26}
                    color={focused ? COLORS.primary : color}
                />
            </View>
            {focused && <View style={styles.activeIndicator} />}
        </View>
    );
};

export default function TabLayout() {
    return (
        <Tabs
            screenOptions={{
                headerShown: false,
                tabBarActiveTintColor: COLORS.primary,
                tabBarInactiveTintColor: COLORS.inactive,
                tabBarStyle: {
                    position: 'absolute',
                    bottom: 20,
                    left: 20,
                    right: 20,
                    backgroundColor: COLORS.background,
                    borderRadius: 30,
                    height: 80,
                    paddingBottom: 15,
                    paddingTop: 12,
                    paddingHorizontal: 15,
                    borderTopWidth: 0,
                    borderWidth: 0,
                    marginHorizontal: 15,
                    ...Platform.select({
                        ios: {
                            shadowColor: COLORS.shadow,
                            shadowOffset: { width: 0, height: 10 },
                            shadowOpacity: 0.15,
                            shadowRadius: 25,
                        },
                        android: {
                            elevation: 15,
                        },
                    }),
                },
                tabBarLabelStyle: {
                    fontSize: 11,
                    fontFamily: 'SFNSText-Bold',
                    fontWeight: '700',
                    letterSpacing: 0.5,
                    marginTop: 8,
                },
                tabBarItemStyle: {
                    paddingVertical: 5,
                },
                tabBarShowLabel: true,
                tabBarHideOnKeyboard: true,
            }}
        >
            <Tabs.Screen
                name="home"
                options={{
                    title: "Home",
                    tabBarIcon: ({ color, focused }) => (
                        <TabBarIcon
                            name={focused ? "home" : "home-outline"}
                            color={color}
                            focused={focused}
                        />
                    ),
                }}
            />
            <Tabs.Screen
                name="recommendation"
                options={{
                    title: "Market",
                    tabBarIcon: ({ color, focused }) => (
                        <TabBarIcon
                            name={focused ? "telescope" : "telescope-outline"}
                            color={color}
                            focused={focused}
                        />
                    ),
                }}
            />
            <Tabs.Screen
                name="fields"
                options={{
                    title: "Fields",
                    tabBarIcon: ({ color, focused }) => (
                        <TabBarIcon
                            name={focused ? "leaf" : "leaf-outline"}
                            color={color}
                            focused={focused}
                        />
                    ),
                }}
            />
            <Tabs.Screen
                name="help"
                options={{
                    title: "Help",
                    tabBarIcon: ({ color, focused }) => (
                        <TabBarIcon
                            name={focused ? "compass" : "compass-outline"}
                            color={color}
                            focused={focused}
                        />
                    ),
                }}
            />
        </Tabs>
    );
}

const styles = StyleSheet.create({
    iconWrapper: {
        alignItems: 'center',
        justifyContent: 'center',
    },
    iconWrapperActive: {
        transform: [{ translateY: -3 }],
    },
    iconContainer: {
        width: 66,
        height: 42,
        justifyContent: 'center',
        alignItems: 'center',
        borderRadius: 18,
        backgroundColor: 'transparent',
    },
    iconContainerActive: {
        backgroundColor: COLORS.activeBackground,
        ...Platform.select({
            ios: {
                shadowColor: COLORS.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.2,
                shadowRadius: 12,
            },
            android: {
                elevation: 5,
                marginBottom: 6,
            },
        }),
    },
    activeIndicator: {
        width: 30,
        height: 3,
        backgroundColor: COLORS.primary,
        borderRadius: 2,
        marginTop: 6,
        marginBottom: -14,
        position: 'absolute',
        bottom: -10,
    },
});



services/iotService.js:
// IoT Device Service
class IoTService {
    constructor() {
        this.baseUrl = 'https://iot-device-backend-dguk.onrender.com';
    }

    async getData() {
        try {
            console.log('Fetching IoT data...');
            const response = await fetch(`${this.baseUrl}/data`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('IoT Data Response:', data);

            return {
                success: true,
                data: data
            };
        } catch (error) {
            console.error('IoT Service Error:', error);
            return {
                success: false,
                error: error.message || 'Failed to fetch IoT data'
            };
        }
    }

    // Helper methods to format data
    formatTemperature(temp) {
        return `${Math.round(temp)}¬∞C`;
    }

    formatHumidity(humidity) {
        return `${Math.round(humidity)}%`;
    }

    formatSoilMoisture(soil) {
        // Convert soil sensor reading to percentage (0-4095 range)
        const percentage = Math.round((soil / 4095) * 100);
        return `${percentage}%`;
    }

    formatLightLevel(light) {
        return light || 'Unknown';
    }

    formatRainLevel(rain) {
        // Rain sensor: higher values typically mean less rain
        if (rain > 3500) return 'No Rain';
        if (rain > 2500) return 'Light Rain';
        if (rain > 1500) return 'Moderate Rain';
        return 'Heavy Rain';
    }

    // Get sensor status colors
    getTemperatureStatus(temp) {
        if (temp < 10) return { status: 'Cold', color: '#64B5F6' };
        if (temp < 25) return { status: 'Optimal', color: '#4CAF50' };
        if (temp < 35) return { status: 'Warm', color: '#FF9800' };
        return { status: 'Hot', color: '#F44336' };
    }

    getHumidityStatus(humidity) {
        if (humidity < 30) return { status: 'Low', color: '#FF9800' };
        if (humidity < 70) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'High', color: '#2196F3' };
    }

    getSoilMoistureStatus(soil) {
        const percentage = (soil / 4095) * 100;
        if (percentage < 20) return { status: 'Dry', color: '#F44336' };
        if (percentage < 60) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'Wet', color: '#2196F3' };
    }

    getLightStatus(light) {
        const status = light?.toLowerCase() || 'unknown';
        switch (status) {
            case 'bright':
                return { status: 'Bright', color: '#FFD54F' };
            case 'moderate':
                return { status: 'Moderate', color: '#FFA726' };
            case 'dark':
                return { status: 'Dark', color: '#90A4AE' };
            default:
                return { status: 'Unknown', color: '#BDBDBD' };
        }
    }

    getRainStatus(rain) {
        if (rain > 3500) return { status: 'Clear', color: '#4CAF50' };
        if (rain > 2500) return { status: 'Light Rain', color: '#2196F3' };
        if (rain > 1500) return { status: 'Moderate Rain', color: '#FF9800' };
        return { status: 'Heavy Rain', color: '#F44336' };
    }
}

export const iotService = new IoTService();


services/marketPriceService.js:
const API_BASE_URL = 'https://api.data.gov.in/resource/9ef84268-d588-465a-a308-a864a43d0070';
const API_KEY = '579b464db66ec23bdd000001bc96414976a7475e48eb5efbbb1c9496';

class MarketPriceService {
    constructor() {
        this.apiKey = API_KEY;
        this.baseUrl = API_BASE_URL;
    }

    // Get market prices for crops
    async getMarketPrices(params = {}) {
        try {
            const {
                limit = 200,  // Increased from 10 to 200 for better geographic coverage
                offset = 0,
                state = '',
                district = '',
                market = '',
                commodity = ''
            } = params;

            const queryParams = new URLSearchParams({
                'api-key': this.apiKey,
                format: 'json',
                limit: limit.toString(),
                offset: offset.toString()
            });

            // Add optional filters
            if (state) queryParams.append('filters[state]', state);
            if (district) queryParams.append('filters[district]', district);
            if (market) queryParams.append('filters[market]', market);
            if (commodity) queryParams.append('filters[commodity]', commodity);

            const url = `${this.baseUrl}?${queryParams.toString()}`;
            console.log('üåê Fetching market prices from:', url);
            console.log('üìã Request params:', { limit, offset, state, district, market, commodity });

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                console.error('‚ùå HTTP Error:', response.status, response.statusText);
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('üì° Market price API response:', {
                recordsCount: data.records?.length || 0,
                total: data.total || 0,
                count: data.count || 0,
                firstRecord: data.records?.[0],
                error: data.error
            });

            return {
                success: true,
                data: data.records || [],
                total: data.total || 0,
                count: data.count || 0
            };

        } catch (error) {
            console.error('Market price API error:', error);
            return {
                success: false,
                error: error.message,
                data: []
            };
        }
    }

    // Get unique states from the data
    async getStates() {
        try {
            const result = await this.getMarketPrices({ limit: 500 });
            if (result.success) {
                const states = [...new Set(result.data.map(item => item.state))].filter(Boolean);
                console.log('Available states in API:', states);
                return { success: true, data: states.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching states:', error);
            return { success: false, data: [] };
        }
    }

    // Get unique districts from the data
    async getDistricts() {
        try {
            const result = await this.getMarketPrices({ limit: 200 });
            if (result.success) {
                const districts = [...new Set(result.data.map(item => item.district))].filter(Boolean);
                console.log('Available districts in API:', districts.slice(0, 10));
                return { success: true, data: districts.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching districts:', error);
            return { success: false, data: [] };
        }
    }

    // Find best matching location from API data
    findBestLocationMatch(userLocation, availableLocations) {
        if (!userLocation || !availableLocations) return null;

        const userLoc = userLocation.toLowerCase().trim();

        // Exact match first
        const exactMatch = availableLocations.find(loc =>
            loc.toLowerCase().trim() === userLoc
        );
        if (exactMatch) return exactMatch;

        // Partial match
        const partialMatch = availableLocations.find(loc =>
            loc.toLowerCase().includes(userLoc) || userLoc.includes(loc.toLowerCase())
        );
        if (partialMatch) return partialMatch;

        // Fuzzy match (first few characters)
        const fuzzyMatch = availableLocations.find(loc => {
            const locLower = loc.toLowerCase().trim();
            return locLower.startsWith(userLoc.substring(0, 3)) ||
                   userLoc.startsWith(locLower.substring(0, 3));
        });

        return fuzzyMatch || null;
    }

    // Get unique commodities from the data
    async getCommodities() {
        try {
            const result = await this.getMarketPrices({ limit: 100 });
            if (result.success) {
                const commodities = [...new Set(result.data.map(item => item.commodity))].filter(Boolean);
                return { success: true, data: commodities.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching commodities:', error);
            return { success: false, data: [] };
        }
    }

    // Format price data for display
    formatPriceData(record) {
        return {
            id: `${record.state}_${record.district}_${record.market}_${record.commodity}_${record.arrival_date}`,
            commodity: record.commodity || 'N/A',
            variety: record.variety || 'N/A',
            state: record.state || 'N/A',
            district: record.district || 'N/A',
            market: record.market || 'N/A',
            arrivalDate: record.arrival_date || 'N/A',
            minPrice: record.min_price ? `‚Çπ${record.min_price}` : 'N/A',
            maxPrice: record.max_price ? `‚Çπ${record.max_price}` : 'N/A',
            modalPrice: record.modal_price ? `‚Çπ${record.modal_price}` : 'N/A',
            priceUnit: record.price_unit || 'Quintal'
        };
    }

    // Get price trend for a specific commodity
    async getPriceTrend(commodity, limit = 20) {
        try {
            const result = await this.getMarketPrices({
                commodity: commodity,
                limit: limit
            });

            if (result.success) {
                const formattedData = result.data.map(record => this.formatPriceData(record));
                return { success: true, data: formattedData };
            }

            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching price trend:', error);
            return { success: false, data: [] };
        }
    }

    // Get market prices near user's location with improved matching
    async getNearbyMarketPrices(locationInfo, limit = 20) {
        try {
            console.log('User location info:', locationInfo);

            if (!locationInfo) {
                console.log('No location info, fetching general market prices');
                return await this.getMarketPrices({ limit });
            }

            let result;
            let isLocal = false;
            let matchedLocation = null;

            // Get available states and districts for matching
            const statesResult = await this.getStates();
            const districtsResult = await this.getDistricts();

            // Try to match user's state with available states
            if (locationInfo.state && statesResult.success) {
                matchedLocation = this.findBestLocationMatch(locationInfo.state, statesResult.data);

                if (matchedLocation) {
                    console.log(`Matched user state "${locationInfo.state}" with API state "${matchedLocation}"`);
                    result = await this.getMarketPrices({
                        state: matchedLocation,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets in state: ${matchedLocation}`);
                        isLocal = true;
                    }
                } else {
                    console.log(`No matching state found for "${locationInfo.state}"`);
                    console.log('Available states sample:', statesResult.data.slice(0, 5));
                }
            }

            // If no state match, try district matching
            if ((!result || !result.success || result.data.length === 0) && locationInfo.district && districtsResult.success) {
                matchedLocation = this.findBestLocationMatch(locationInfo.district, districtsResult.data);

                if (matchedLocation) {
                    console.log(`Matched user district "${locationInfo.district}" with API district "${matchedLocation}"`);
                    result = await this.getMarketPrices({
                        district: matchedLocation,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets in district: ${matchedLocation}`);
                        isLocal = true;
                    }
                } else {
                    console.log(`No matching district found for "${locationInfo.district}"`);
                    console.log('Available districts sample:', districtsResult.data.slice(0, 5));
                }
            }

            // Try exact location names as fallback
            if (!result || !result.success || result.data.length === 0) {
                console.log('Trying exact location names as fallback...');

                // Try city name as state
                if (locationInfo.city) {
                    console.log('Trying city as state:', locationInfo.city);
                    result = await this.getMarketPrices({
                        state: locationInfo.city,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets using city as state`);
                        isLocal = true;
                        matchedLocation = locationInfo.city;
                    }
                }

                // Try city name as district
                if ((!result || !result.success || result.data.length === 0) && locationInfo.city) {
                    console.log('Trying city as district:', locationInfo.city);
                    result = await this.getMarketPrices({
                        district: locationInfo.city,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets using city as district`);
                        isLocal = true;
                        matchedLocation = locationInfo.city;
                    }
                }
            }

            // If still no data, fetch general market prices
            if (!result || !result.success || result.data.length === 0) {
                console.log('No local data found, fetching general market prices');
                result = await this.getMarketPrices({ limit });
                isLocal = false;
                matchedLocation = null;
            }

            if (result.success) {
                const formattedData = result.data.map(record => this.formatPriceData(record));
                return {
                    success: true,
                    data: formattedData,
                    isLocal,
                    locationUsed: matchedLocation
                };
            }

            return { success: false, data: [], isLocal: false };
        } catch (error) {
            console.error('Error fetching nearby market prices:', error);
            return { success: false, data: [], isLocal: false };
        }
    }

    // Calculate distance between two coordinates (Haversine formula)
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the Earth in kilometers
        const dLat = this.deg2rad(lat2 - lat1);
        const dLon = this.deg2rad(lon2 - lon1);
        const a =
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distance in kilometers
        return distance;
    }

    deg2rad(deg) {
        return deg * (Math.PI/180);
    }
}

export const marketPriceService = new MarketPriceService();



services/weatherService.js:

// Weather API Service
import Constants from 'expo-constants';

// Try multiple ways to get the API key
const getApiKey = () => {
    // Method 1: From Expo Constants (app.config.js)
    if (Constants.expoConfig?.extra?.weatherApiKey) {
        return Constants.expoConfig.extra.weatherApiKey;
    }

    // Method 2: From process.env (direct access)
    if (process.env.EXPO_PUBLIC_WEATHER_API_KEY) {
        return process.env.EXPO_PUBLIC_WEATHER_API_KEY;
    }

    // Method 3: Fallback to hardcoded (not recommended for production)
    return '3b0832ddf6dc414c815190329252410';
};

const WEATHER_API_KEY = getApiKey();
const BASE_URL = 'https://api.weatherapi.com/v1';

export const weatherService = {
    // Test API key
    testApiKey: async () => {
        try {
            console.log('Testing API key:', WEATHER_API_KEY);
            const response = await fetch(
                `${BASE_URL}/current.json?key=${WEATHER_API_KEY}&q=London&aqi=no`
            );

            const responseText = await response.text();
            console.log('Test API Response:', response.status, responseText);

            return {
                success: response.ok,
                status: response.status,
                data: responseText
            };
        } catch (error) {
            console.error('API Test error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    },

    // Get current weather by coordinates
    getCurrentWeather: async (latitude, longitude) => {
        try {
            console.log('API Key being used:', WEATHER_API_KEY ? 'Present' : 'Missing');
            console.log('Making request to:', `${BASE_URL}/current.json?key=${WEATHER_API_KEY?.substring(0, 8)}...&q=${latitude},${longitude}&aqi=no`);

            const response = await fetch(
                `${BASE_URL}/current.json?key=${WEATHER_API_KEY}&q=${latitude},${longitude}&aqi=no`
            );

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Response:', response.status, errorText);
                throw new Error(`Weather API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            return {
                success: true,
                data
            };
        } catch (error) {
            console.error('Weather service error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    },

    // Get weather forecast (optional for future use)
    getForecast: async (latitude, longitude, days = 3) => {
        try {
            const response = await fetch(
                `${BASE_URL}/forecast.json?key=${WEATHER_API_KEY}&q=${latitude},${longitude}&days=${days}&aqi=no&alerts=no`
            );

            if (!response.ok) {
                throw new Error(`Weather API error: ${response.status}`);
            }

            const data = await response.json();
            return {
                success: true,
                data
            };
        } catch (error) {
            console.error('Weather forecast service error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
};


app.config.js:


import 'dotenv/config';

export default {
    expo: {
        name: "AgroSync",
        slug: "AgroSync",
        version: "1.0.0",
        orientation: "portrait",
        icon: "./assets/images/boardingImage.png",
        scheme: "agrosync",
        userInterfaceStyle: "automatic",
        newArchEnabled: true,

        ios: { supportsTablet: true },

        android: {
            adaptiveIcon: {
                backgroundColor: "#E6F4FE",
                foregroundImage: "./assets/images/android-icon-foreground.png",
                backgroundImage: "./assets/images/android-icon-background.png",
                monochromeImage: "./assets/images/android-icon-monochrome.png"
            },
            edgeToEdgeEnabled: true,
            predictiveBackGestureEnabled: false
        },

        web: {
            output: "static",
            favicon: "./assets/images/boardingImage.png"
        },

        plugins: [
            "expo-router",
            [
                "expo-splash-screen",
                {
                    image: "./assets/images/boardingImage.png",
                    imageWidth: 200,
                    resizeMode: "contain",
                    backgroundColor: "#ffffff",
                    dark: { backgroundColor: "#000000" }
                }
            ],
            "expo-font",
            "expo-sqlite"
        ],

        experiments: {
            typedRoutes: true,
            reactCompiler: true
        },

        extra: {
            supabaseUrl: process.env.EXPO_SUPABASE_URL,
            supabaseAnonKey: process.env.EXPO_SUPABASE_ANON_KEY,
            weatherApiKey: process.env.EXPO_PUBLIC_WEATHER_API_KEY
        }
    }
};



