// app/(tabs)/fields/[id].jsx
import { useEffect, useMemo, useState } from "react";
import { ScrollView, StyleSheet, Text, View, Pressable } from "react-native";
import ScreenWrapper from "../../../components/ScreenWrapper";
import { theme } from "../../../constants/theme";
import { hp, wp } from "../../../helpers/common";
import { iotService } from "../../../services/iotService";
import { weatherService } from "../../../services/weatherService";
import { predictSoilParams, generateCropDescriptionBoth } from "../../../services/geminiService";
import { getCropRecommendation } from "../../../services/cropRecommendationService";
import LottieView from "lottie-react-native";
import { useFieldData, useFields } from "../../../contexts/FieldContext";
import {router, useLocalSearchParams} from "expo-router";
import Ionicons from "@expo/vector-icons/Ionicons";
import BackButton from "../../../components/BackButton";

const TTL = 5 * 60 * 1000; // 5 mins

export default function FieldDetails() {
    const { id } = useLocalSearchParams();
    const { fields, fieldData, setFieldData, lastFetchedAt, setLastFetchedAt } = useFieldData();
    const field = fields.find(f => f.id === id) || { id, name: "Field" };

    const [loading, setLoading] = useState(true);
    const [iot, setIot] = useState(null);
    const [weather, setWeather] = useState(null);
    const [predicted, setPredicted] = useState(null);
    const [recommendation, setRecommendation] = useState(null);
    const [error, setError] = useState("");

    const [englishDesc, setEnglishDesc] = useState(null);
    const [hindiDesc, setHindiDesc] = useState(null);
    const [isHindi, setIsHindi] = useState(false);

    const moisturePct = useMemo(() => {
        if (!iot?.soil && iot?.soil !== 0) return null;
        return Math.max(0, Math.min(100, Math.round((Number(iot.soil) / 4095) * 100)));
    }, [iot?.soil]);

    const temperature = iot?.temperature ?? fieldData.temperature ?? null;
    const humidity = iot?.humidity ?? fieldData.humidity ?? null;
    const rainfall = weather?.current?.precip_mm ?? fieldData.rainfall ?? null;

    const fetchAll = async () => {
        try {
            setLoading(true);

            const iotRes = await iotService.getData();
            if (!iotRes.success) throw new Error(iotRes.error || "IoT fetch failed");
            setIot(iotRes.data);

            const loc = await weatherService.getCachedOrCurrentLocation?.();
            const lat = loc?.latitude ?? 28.6139;
            const lon = loc?.longitude ?? 77.2090;
            const w = await weatherService.getCurrentWeather(lat, lon);
            if (!w.success) throw new Error(w.error || "Weather fetch failed");
            setWeather(w.data);

            const preds = await predictSoilParams({
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
            });
            setPredicted(preds);

            const payload = {
                K: preds.K,
                N: preds.N,
                P: preds.P,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                pH: preds.pH,
                rainfall: w.data?.current?.precip_mm ?? 0,
                temperature: iotRes.data.temperature,
            };
            const rec = await getCropRecommendation(payload);
            setRecommendation(rec);

            const both = await generateCropDescriptionBoth({
                crop: rec.best_crop,
                N: preds.N,
                P: preds.P,
                K: preds.K,
                pH: preds.pH,
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
            });
            setEnglishDesc(both.english);
            setHindiDesc(both.hindi);

            setFieldData({
                temperature: iotRes.data.temperature,
                humidity: iotRes.data.humidity,
                moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                rainfall: w.data?.current?.precip_mm ?? 0,
                N: preds.N,
                P: preds.P,
                K: preds.K,
                pH: preds.pH,

                recommendation: rec,
                englishDesc: both.english,
                hindiDesc: both.hindi,
            });


            setLastFetchedAt(Date.now());
        } catch (e) {
            console.log("üí• error:", e);
            setError(e.message || JSON.stringify(e));
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        if (lastFetchedAt && Date.now() - lastFetchedAt < TTL && fieldData.temperature !== null) {
            setLoading(false);
        } else {
            fetchAll();
        }
    }, [id]);

    const handleTranslate = () => setIsHindi(!isHindi);

    return (
        <ScreenWrapper bg="white">
            <View style={styles.headerRow}>
                <BackButton router={router} />
                <Text style={styles.pageTitle}>{field.name}</Text>
                <Pressable onPress={fetchAll}>
                    <Ionicons name="refresh" size={26} color={theme.colors.primary} />
                </Pressable>
            </View>

            <ScrollView contentContainerStyle={styles.container}>
                {loading ? (
                    <View style={styles.loadingCard}>
                        <LottieView
                            source={require("../../../assets/animations/loading.json")}
                            style={styles.loadingAnimation}
                            autoPlay
                            loop
                            speed={1.2}
                        />
                        <Text style={styles.loadingText}>Collecting field data‚Ä¶</Text>
                    </View>
                ) : error ? (
                    <View style={styles.errorCard}>
                        <Text style={styles.errorText}>‚ö†Ô∏è {error}</Text>
                    </View>
                ) : (
                    <>
                        <View style={styles.card}>
                            <Text style={styles.cardTitle}>Current Inputs</Text>

                            <View style={styles.row}>
                                <Item label="Temperature" value={temperature ?? "‚Äî"} unit="¬∞C" source="IoT" />
                                <Item label="Humidity" value={humidity ?? "‚Äî"} unit="%" source="IoT" />
                            </View>

                            <View style={styles.row}>
                                <Item label="Moisture" value={moisturePct ?? fieldData.moisture ?? "‚Äî"} unit="%" source="IoT" />
                                <Item label="Rainfall" value={rainfall ?? 0} unit="mm" source="Weather" />
                            </View>

                            <View style={styles.separator} />

                            <View style={styles.row}>
                                <Item label="Nitrogen (N)" value={predicted?.N ?? fieldData.N ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Phosphorus (P)" value={predicted?.P ?? fieldData.P ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                            </View>
                            <View style={styles.row}>
                                <Item label="Potassium (K)" value={predicted?.K ?? fieldData.K ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Soil pH" value={predicted?.pH ?? fieldData.pH ?? "‚Äî"} unit="" source="Predicted" />
                            </View>
                        </View>

                        <View style={styles.card}>
                            <Text style={styles.cardTitle}>Today‚Äôs Recommendation</Text>
                            {recommendation || fieldData.recommendation ? (
                                <View style={{ gap: hp(1) }}>
                                    <Text style={styles.recoCrop}>{(recommendation || fieldData.recommendation)?.best_crop}</Text>
                                    <Text style={styles.recoProb}>
                                        Confidence: {Number((recommendation || fieldData.recommendation)?.probability).toFixed(2)}
                                    </Text>

                                    {(englishDesc || fieldData.englishDesc) && (
                                        <>
                                            <View style={styles.descBox}>
                                                <Text style={styles.descPlaceholder}>
                                                    {isHindi
                                                        ? (hindiDesc || fieldData.hindiDesc)
                                                        : (englishDesc || fieldData.englishDesc)
                                                    }
                                                </Text>
                                            </View>


                                            <Pressable
                                                onPress={handleTranslate}
                                                style={styles.translateBtn}
                                            >
                                                <Text style={styles.translateBtnText}>
                                                    {isHindi ? "Show English" : "Translate to Hindi"}
                                                </Text>
                                            </Pressable>
                                        </>
                                    )}
                                </View>
                            ) : (
                                <Text style={styles.descPlaceholder}>No recommendation available.</Text>
                            )}
                        </View>
                    </>
                )}
            </ScrollView>
        </ScreenWrapper>
    );
}

function Item({ label, value, unit, source }) {
    return (
        <View style={styles.item}>
            <Text style={styles.itemLabel}>{label}</Text>
            <Text style={styles.itemValue}>
                {value}
                {unit ? ` ${unit}` : ""} <Text style={styles.sourceTag}>({source})</Text>
            </Text>
        </View>
    );
}

const styles = StyleSheet.create({
    headerRow: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: 10,
    },
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(0.5),
        paddingBottom: hp(12),
        gap: hp(2),
    },
    pageTitle: {
        fontSize: hp(2.4),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
        gap: hp(1.2),
    },
    cardTitle: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    row: {
        flexDirection: "row",
        gap: wp(4),
    },
    item: {
        flex: 1,
        gap: hp(0.5),
    },
    itemLabel: {
        fontSize: hp(1.5),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    itemValue: {
        fontSize: hp(2.1),
        color: theme.colors.textDark,
        fontFamily: "SFNSDisplay-Bold",
    },
    sourceTag: {
        fontSize: hp(1.5),
        color: theme.colors.primary,
        fontFamily: "SFNSText-Medium",
    },
    separator: {
        height: 1,
        backgroundColor: "rgba(0,0,0,0.06)",
        marginVertical: hp(0.5),
    },
    loadingCard: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(6),
        alignItems: "center",
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
    },
    loadingAnimation: { width: wp(20), height: wp(20) },
    loadingText: {
        marginTop: hp(1),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    errorCard: {
        backgroundColor: "#fff5f5",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "#ffd6d6",
    },
    errorText: {
        color: "#c0392b",
        fontFamily: "SFNSDisplay-Bold",
    },
    recoCrop: {
        fontSize: hp(2.2),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
    recoProb: {
        fontSize: hp(1.8),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textDark,
    },
    descBox: {
        borderWidth: 1,
        borderColor: "rgba(0,0,0,0.08)",
        borderRadius: 12,
        padding: wp(3),
        backgroundColor: "#fafafa",
    },
    descPlaceholder: {
        fontSize: hp(1.6),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    translateBtn: {
        backgroundColor: theme.colors.primary,
        paddingVertical: hp(1.2),
        borderRadius: 8,
        alignItems: "center",
    },
    translateBtnText: {
        color: "white",
        fontFamily: "SFNSText-Medium",
    },
});





// app/(tabs)/fields/_layout.jsx
import { Stack } from "expo-router";

export default function FieldsStackLayout() {
    return (
        <Stack screenOptions={{ headerShown: false }} />
    );
}






// app/(tabs)/fields/index.jsx
import { View, Text, Pressable, StyleSheet, Alert, ScrollView } from "react-native";
import ScreenWrapper from "../../../components/ScreenWrapper";
import { hp, wp } from "../../../helpers/common";
import { theme } from "../../../constants/theme";
import { useRouter } from "expo-router";
import { useFields } from "../../../contexts/FieldContext";

export default function FieldsIndex() {
    const router = useRouter();
    const { fields } = useFields(); // future-proof list

    return (
        <ScreenWrapper bg="white">
            <ScrollView contentContainerStyle={styles.container}>
                <Text style={styles.title}>Your Fields</Text>

                {fields.map((f) => (
                    <Pressable
                        key={f.id}
                        style={styles.card}
                        onPress={() => router.push(`/fields/${f.id}`)}
                    >
                        <Text style={styles.cardTitle}>{f.name}</Text>
                        <Text style={styles.small}>Tap to open details</Text>
                    </Pressable>
                ))}

                <Pressable
                    style={[styles.card, styles.addCard]}
                    onPress={() =>
                        Alert.alert("Coming Soon", "Multiple fields support is coming soon!")
                    }
                >
                    <Text style={styles.addText}>+ Add Field</Text>
                </Pressable>
            </ScrollView>
        </ScreenWrapper>
    );
}

const styles = StyleSheet.create({
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        gap: hp(2),
        paddingBottom: hp(20),
    },
    title: {
        fontSize: hp(2.4),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
        marginBottom: hp(1),
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(5),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
    },
    cardTitle: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    small: {
        marginTop: hp(0.5),
        fontSize: hp(1.5),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    addCard: { alignItems: "center" },
    addText: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
});


// contexts/FieldContext.js
import { createContext, useContext, useState, useMemo } from "react";

const FieldContext = createContext(null);

export function FieldProvider({ children }) {
    const [fields, setFields] = useState([
        { id: "field_1", name: "Field 1", iotId: "default" },
    ]);

    const [fieldData, setFieldData] = useState({
        temperature: null,
        humidity: null,
        moisture: null,
        rainfall: null,
        N: null,
        P: null,
        K: null,
        pH: null,

        // new caching
        recommendation: null,
        englishDesc: null,
        hindiDesc: null,
    });


    const [lastFetchedAt, setLastFetchedAt] = useState(null);

    const getFieldById = (id) => fields.find((f) => f.id === id) || null;

    const value = useMemo(
        () => ({
            fields,
            setFields,
            fieldData,
            setFieldData,
            lastFetchedAt,
            setLastFetchedAt,
            getFieldById,
        }),
        [fields, fieldData, lastFetchedAt]
    );

    return <FieldContext.Provider value={value}>{children}</FieldContext.Provider>;
}

export function useFieldData() {
    return useContext(FieldContext);
}

export function useFields() {
    return useContext(FieldContext);
}



// ============================================
// /services/cropRecommendationService.js
// ============================================

const RECOM_BASE = "https://crop-recommender-engine.onrender.com";

export async function getCropRecommendation(payload) {
    const res = await fetch(`${RECOM_BASE}/predict`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
    });
    if (!res.ok) {
        const err = await res.text();
        throw new Error(`Recommender error: ${res.status} ${err}`);
    }
    return res.json(); // { best_crop, probability }
}



// =============================
// /services/geminiService.js
// =============================

const GEMINI_API_KEY = process.env.EXPO_PUBLIC_GEMINI_API_KEY;
const GEMINI_ENDPOINT =
    "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent";


function buildPrompt({ temperature, humidity, moisture, rainfall }) {
    return `You are an agronomy assistant. Given current field conditions, estimate soil macronutrients and pH for use in a crop recommendation model.

Return ONLY a strict minified JSON object with numeric values (no comments, no text around it), like:
{"N":80,"P":35,"K":40,"pH":6.5}

Constraints:
- N, P, K are in kg/ha, integers 0-300
- pH is 3.5 - 9.5 (one decimal)
- If information is insufficient, infer a reasonable value from typical Indian loamy soils in Kharif season.

Conditions:
- temperature_C: ${temperature}
- humidity_pct: ${humidity}
- soil_moisture_pct: ${moisture}
- rainfall_mm: ${rainfall}
`;
}

function extractJsonFromText(text) {
    try {
        // If it's already pure JSON
        return JSON.parse(text);
    } catch (_) {
        // Try to locate the first {...} block
        const start = text.indexOf("{");
        const end = text.lastIndexOf("}");
        if (start !== -1 && end !== -1 && end > start) {
            const jsonSlice = text.slice(start, end + 1);
            return JSON.parse(jsonSlice);
        }
        throw new Error("Gemini response did not contain valid JSON.");
    }
}

export async function predictSoilParams({ temperature, humidity, moisture, rainfall }) {
    if (!GEMINI_API_KEY) {
        throw new Error("Missing EXPO_PUBLIC_GEMINI_API_KEY");
    }

    const body = {
        contents: [
            {
                role: "user",
                parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
            },
        ],
        generationConfig: {
            temperature: 0.4,
            maxOutputTokens: 128,
        },
    };

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [
                {
                    role: "user",
                    parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
                },
            ],
        }),
    });


    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
    const parsed = extractJsonFromText(text);

    const N = Math.max(0, Math.min(300, Math.round(Number(parsed.N))));
    const P = Math.max(0, Math.min(300, Math.round(Number(parsed.P))));
    const K = Math.max(0, Math.min(300, Math.round(Number(parsed.K))));
    const pH = Math.max(3.5, Math.min(9.5, Number(parsed.pH)));

    if ([N, P, K].some((v) => Number.isNaN(v)) || Number.isNaN(pH)) {
        throw new Error("Gemini returned invalid numbers");
    }

    return { N, P, K, pH: Number(pH.toFixed(1)) };
}

// --- Helpers: robust JSON extraction/parsing from LLM text ---
// Finds the first balanced {...} JSON object (ignores braces inside quotes)
function findFirstJsonObject(s) {
    if (!s) return null;

    // strip common wrappers
    let t = s.trim().replace(/```json/gi, "").replace(/```/g, "");
    // also strip any preface before the first '{'
    const firstBrace = t.indexOf("{");
    if (firstBrace > 0) t = t.slice(firstBrace);

    let depth = 0;
    let inString = false;
    let escape = false;

    for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        if (inString) {
            if (escape) {
                escape = false;
            } else if (ch === "\\") {
                escape = true;
            } else if (ch === "\"") {
                inString = false;
            }
            continue;
        }

        if (ch === "\"") {
            inString = true;
            continue;
        }
        if (ch === "{") {
            depth++;
            continue;
        }
        if (ch === "}") {
            depth--;
            if (depth === 0) {
                // slice inclusive of this closing brace
                return t.slice(0, i + 1);
            }
            continue;
        }
    }
    return null; // not found
}

function safeParseGeminiJson(text) {
    const jsonSlice = findFirstJsonObject(text);
    if (!jsonSlice) throw new Error("No JSON object found in Gemini response.");
    // Clean any stray leading commas/colons/newlines
    const clean = jsonSlice.replace(/^[,:\\s]+/, "");
    return JSON.parse(clean);
}

// =====================
// ONE-CALL: English + Hindi description
// =====================
export async function generateCropDescriptionBoth({
                                                      crop, N, P, K, pH, temperature, humidity, moisture, rainfall
                                                  }) {
    const prompt = `
You are an agriculture advisor.
Generate TWO versions of a very short advice (max 3 lines) for a farmer based on this crop and field data.

crop=${crop}
N=${N}, P=${P}, K=${K}, pH=${pH}
temperature=${temperature}C, humidity=${humidity}%, moisture=${moisture}%, rainfall=${rainfall}mm

Return EXACTLY and ONLY this JSON (no extra words, no backticks):
{"english":"<simple english, farmer-friendly>", "hindi":"<simple Hindi, farmer-friendly>"}
`;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const raw = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

    try {
        const obj = safeParseGeminiJson(raw);
        // Minimal sanity
        if (!obj || typeof obj !== "object") throw new Error("Parsed result is not an object");
        if (typeof obj.english !== "string" || typeof obj.hindi !== "string") {
            throw new Error("Parsed JSON missing 'english' or 'hindi' strings");
        }
        return obj; // { english, hindi }
    } catch (e) {
        // Log raw to console to debug quickly, but don't crash the app silently
        console.log("üîé Gemini raw description text =>", raw);
        throw e;
    }
}


// =====================
// HELP: Ask AI with context
// =====================
export async function helpAnswer({ question, context }) {
    if (!question || !question.trim()) return "";

    const prompt = `
You are an agriculture advisor inside AgroSync app.
This is the current field context:

Temperature: ${context.temperature}¬∞C
Humidity: ${context.humidity}%
Moisture: ${context.moisture}%
Rainfall: ${context.rainfall}mm
N: ${context.N}
P: ${context.P}
K: ${context.K}
pH: ${context.pH}

User question:
${question.trim()}

Answer in 3-5 short lines, simple farmer-friendly English.
Do not use codeblocks or markdown.
  `;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini Help error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
}



//
// // =====================
// // translate to Hindi
// // =====================
// export async function translateToHindi(text) {
//     const prompt = `Translate this to simple Hindi suitable for farmers:\n${text}`;
//
//     const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
//         method:"POST",
//         headers:{ "Content-Type":"application/json" },
//         body:JSON.stringify({
//             contents:[{role:"user", parts:[{text:prompt}]}]
//         })
//     });
//
//     const data = await res.json();
//     return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
// }



// IoT Device Service
class IoTService {
    constructor() {
        this.baseUrl = 'https://iot-device-backend-dguk.onrender.com';
        // this.baseUrl = 'https://mocki.io/v1/1588969d-1261-4a66-a509-2ce3bb95bd8a';
    }

    async getData() {
        try {
            console.log('Fetching IoT data...');
            const response = await fetch(`${this.baseUrl}/data`, {
            //     const response = await fetch(`${this.baseUrl}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('IoT Data Response:', data);

            return {
                success: true,
                data: data
            };
        } catch (error) {
            console.error('IoT Service Error:', error);
            return {
                success: false,
                error: error.message || 'Failed to fetch IoT data'
            };
        }
    }

    // Helper methods to format data
    formatTemperature(temp) {
        return `${Math.round(temp)}¬∞C`;
    }

    formatHumidity(humidity) {
        return `${Math.round(humidity)}%`;
    }

    formatSoilMoisture(soil) {
        // Convert soil sensor reading to percentage (0-4095 range)
        const percentage = Math.round((soil / 4095) * 100);
        return `${percentage}%`;
    }

    formatLightLevel(light) {
        return light || 'Unknown';
    }

    formatRainLevel(rain) {
        // Rain sensor: higher values typically mean less rain
        if (rain > 3500) return 'No Rain';
        if (rain > 2500) return 'Light Rain';
        if (rain > 1500) return 'Moderate Rain';
        return 'Heavy Rain';
    }

    // Get sensor status colors
    getTemperatureStatus(temp) {
        if (temp < 10) return { status: 'Cold', color: '#64B5F6' };
        if (temp < 25) return { status: 'Optimal', color: '#4CAF50' };
        if (temp < 35) return { status: 'Warm', color: '#FF9800' };
        return { status: 'Hot', color: '#F44336' };
    }

    getHumidityStatus(humidity) {
        if (humidity < 30) return { status: 'Low', color: '#FF9800' };
        if (humidity < 70) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'High', color: '#2196F3' };
    }

    getSoilMoistureStatus(soil) {
        const percentage = (soil / 4095) * 100;
        if (percentage < 20) return { status: 'Dry', color: '#F44336' };
        if (percentage < 60) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'Wet', color: '#2196F3' };
    }

    getLightStatus(light) {
        const status = light?.toLowerCase() || 'unknown';
        switch (status) {
            case 'bright':
                return { status: 'Bright', color: '#FFD54F' };
            case 'moderate':
                return { status: 'Moderate', color: '#FFA726' };
            case 'dark':
                return { status: 'Dark', color: '#90A4AE' };
            default:
                return { status: 'Unknown', color: '#BDBDBD' };
        }
    }

    getRainStatus(rain) {
        if (rain > 3500) return { status: 'Clear', color: '#4CAF50' };
        if (rain > 2500) return { status: 'Light Rain', color: '#2196F3' };
        if (rain > 1500) return { status: 'Moderate Rain', color: '#FF9800' };
        return { status: 'Heavy Rain', color: '#F44336' };
    }
}

export const iotService = new IoTService();


const API_BASE_URL = 'https://api.data.gov.in/resource/9ef84268-d588-465a-a308-a864a43d0070';
const API_KEY = '579b464db66ec23bdd000001bc96414976a7475e48eb5efbbb1c9496';

class MarketPriceService {
    constructor() {
        this.apiKey = API_KEY;
        this.baseUrl = API_BASE_URL;
    }

    // Get market prices for crops
    async getMarketPrices(params = {}) {
        try {
            const {
                limit = 200,  // Increased from 10 to 200 for better geographic coverage
                offset = 0,
                state = '',
                district = '',
                market = '',
                commodity = ''
            } = params;

            const queryParams = new URLSearchParams({
                'api-key': this.apiKey,
                format: 'json',
                limit: limit.toString(),
                offset: offset.toString()
            });

            // Add optional filters
            if (state) queryParams.append('filters[state]', state);
            if (district) queryParams.append('filters[district]', district);
            if (market) queryParams.append('filters[market]', market);
            if (commodity) queryParams.append('filters[commodity]', commodity);

            const url = `${this.baseUrl}?${queryParams.toString()}`;
            console.log('üåê Fetching market prices from:', url);
            console.log('üìã Request params:', { limit, offset, state, district, market, commodity });

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                console.error('‚ùå HTTP Error:', response.status, response.statusText);
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('üì° Market price API response:', {
                recordsCount: data.records?.length || 0,
                total: data.total || 0,
                count: data.count || 0,
                firstRecord: data.records?.[0],
                error: data.error
            });

            return {
                success: true,
                data: data.records || [],
                total: data.total || 0,
                count: data.count || 0
            };

        } catch (error) {
            console.error('Market price API error:', error);
            return {
                success: false,
                error: error.message,
                data: []
            };
        }
    }

    // Get unique states from the data
    async getStates() {
        try {
            const result = await this.getMarketPrices({ limit: 500 });
            if (result.success) {
                const states = [...new Set(result.data.map(item => item.state))].filter(Boolean);
                console.log('Available states in API:', states);
                return { success: true, data: states.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching states:', error);
            return { success: false, data: [] };
        }
    }

    // Get unique districts from the data
    async getDistricts() {
        try {
            const result = await this.getMarketPrices({ limit: 200 });
            if (result.success) {
                const districts = [...new Set(result.data.map(item => item.district))].filter(Boolean);
                console.log('Available districts in API:', districts.slice(0, 10));
                return { success: true, data: districts.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching districts:', error);
            return { success: false, data: [] };
        }
    }

    // Find best matching location from API data
    findBestLocationMatch(userLocation, availableLocations) {
        if (!userLocation || !availableLocations) return null;

        const userLoc = userLocation.toLowerCase().trim();

        // Exact match first
        const exactMatch = availableLocations.find(loc =>
            loc.toLowerCase().trim() === userLoc
        );
        if (exactMatch) return exactMatch;

        // Partial match
        const partialMatch = availableLocations.find(loc =>
            loc.toLowerCase().includes(userLoc) || userLoc.includes(loc.toLowerCase())
        );
        if (partialMatch) return partialMatch;

        // Fuzzy match (first few characters)
        const fuzzyMatch = availableLocations.find(loc => {
            const locLower = loc.toLowerCase().trim();
            return locLower.startsWith(userLoc.substring(0, 3)) ||
                   userLoc.startsWith(locLower.substring(0, 3));
        });

        return fuzzyMatch || null;
    }

    // Get unique commodities from the data
    async getCommodities() {
        try {
            const result = await this.getMarketPrices({ limit: 100 });
            if (result.success) {
                const commodities = [...new Set(result.data.map(item => item.commodity))].filter(Boolean);
                return { success: true, data: commodities.sort() };
            }
            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching commodities:', error);
            return { success: false, data: [] };
        }
    }

    // Format price data for display
    formatPriceData(record) {
        return {
            id: `${record.state}_${record.district}_${record.market}_${record.commodity}_${record.arrival_date}`,
            commodity: record.commodity || 'N/A',
            variety: record.variety || 'N/A',
            state: record.state || 'N/A',
            district: record.district || 'N/A',
            market: record.market || 'N/A',
            arrivalDate: record.arrival_date || 'N/A',
            minPrice: record.min_price ? `‚Çπ${record.min_price}` : 'N/A',
            maxPrice: record.max_price ? `‚Çπ${record.max_price}` : 'N/A',
            modalPrice: record.modal_price ? `‚Çπ${record.modal_price}` : 'N/A',
            priceUnit: record.price_unit || 'Quintal'
        };
    }

    // Get price trend for a specific commodity
    async getPriceTrend(commodity, limit = 20) {
        try {
            const result = await this.getMarketPrices({
                commodity: commodity,
                limit: limit
            });

            if (result.success) {
                const formattedData = result.data.map(record => this.formatPriceData(record));
                return { success: true, data: formattedData };
            }

            return { success: false, data: [] };
        } catch (error) {
            console.error('Error fetching price trend:', error);
            return { success: false, data: [] };
        }
    }

    // Get market prices near user's location with improved matching
    async getNearbyMarketPrices(locationInfo, limit = 20) {
        try {
            console.log('User location info:', locationInfo);

            if (!locationInfo) {
                console.log('No location info, fetching general market prices');
                return await this.getMarketPrices({ limit });
            }

            let result;
            let isLocal = false;
            let matchedLocation = null;

            // Get available states and districts for matching
            const statesResult = await this.getStates();
            const districtsResult = await this.getDistricts();

            // Try to match user's state with available states
            if (locationInfo.state && statesResult.success) {
                matchedLocation = this.findBestLocationMatch(locationInfo.state, statesResult.data);

                if (matchedLocation) {
                    console.log(`Matched user state "${locationInfo.state}" with API state "${matchedLocation}"`);
                    result = await this.getMarketPrices({
                        state: matchedLocation,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets in state: ${matchedLocation}`);
                        isLocal = true;
                    }
                } else {
                    console.log(`No matching state found for "${locationInfo.state}"`);
                    console.log('Available states sample:', statesResult.data.slice(0, 5));
                }
            }

            // If no state match, try district matching
            if ((!result || !result.success || result.data.length === 0) && locationInfo.district && districtsResult.success) {
                matchedLocation = this.findBestLocationMatch(locationInfo.district, districtsResult.data);

                if (matchedLocation) {
                    console.log(`Matched user district "${locationInfo.district}" with API district "${matchedLocation}"`);
                    result = await this.getMarketPrices({
                        district: matchedLocation,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets in district: ${matchedLocation}`);
                        isLocal = true;
                    }
                } else {
                    console.log(`No matching district found for "${locationInfo.district}"`);
                    console.log('Available districts sample:', districtsResult.data.slice(0, 5));
                }
            }

            // Try exact location names as fallback
            if (!result || !result.success || result.data.length === 0) {
                console.log('Trying exact location names as fallback...');

                // Try city name as state
                if (locationInfo.city) {
                    console.log('Trying city as state:', locationInfo.city);
                    result = await this.getMarketPrices({
                        state: locationInfo.city,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets using city as state`);
                        isLocal = true;
                        matchedLocation = locationInfo.city;
                    }
                }

                // Try city name as district
                if ((!result || !result.success || result.data.length === 0) && locationInfo.city) {
                    console.log('Trying city as district:', locationInfo.city);
                    result = await this.getMarketPrices({
                        district: locationInfo.city,
                        limit: limit
                    });

                    if (result.success && result.data.length > 0) {
                        console.log(`Found ${result.data.length} markets using city as district`);
                        isLocal = true;
                        matchedLocation = locationInfo.city;
                    }
                }
            }

            // If still no data, fetch general market prices
            if (!result || !result.success || result.data.length === 0) {
                console.log('No local data found, fetching general market prices');
                result = await this.getMarketPrices({ limit });
                isLocal = false;
                matchedLocation = null;
            }

            if (result.success) {
                const formattedData = result.data.map(record => this.formatPriceData(record));
                return {
                    success: true,
                    data: formattedData,
                    isLocal,
                    locationUsed: matchedLocation
                };
            }

            return { success: false, data: [], isLocal: false };
        } catch (error) {
            console.error('Error fetching nearby market prices:', error);
            return { success: false, data: [], isLocal: false };
        }
    }

    // Calculate distance between two coordinates (Haversine formula)
    calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the Earth in kilometers
        const dLat = this.deg2rad(lat2 - lat1);
        const dLon = this.deg2rad(lon2 - lon1);
        const a =
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distance in kilometers
        return distance;
    }

    deg2rad(deg) {
        return deg * (Math.PI/180);
    }
}

export const marketPriceService = new MarketPriceService();


// Weather API Service
import Constants from 'expo-constants';

// Try multiple ways to get the API key
const getApiKey = () => {
    // Method 1: From Expo Constants (app.config.js)
    if (Constants.expoConfig?.extra?.weatherApiKey) {
        return Constants.expoConfig.extra.weatherApiKey;
    }

    // Method 2: From process.env (direct access)
    if (process.env.EXPO_PUBLIC_WEATHER_API_KEY) {
        return process.env.EXPO_PUBLIC_WEATHER_API_KEY;
    }

    // Method 3: Fallback to hardcoded (not recommended for production)
    return '3b0832ddf6dc414c815190329252410';
};

const WEATHER_API_KEY = getApiKey();
const BASE_URL = 'https://api.weatherapi.com/v1';

export const weatherService = {
    // Test API key
    testApiKey: async () => {
        try {
            console.log('Testing API key:', WEATHER_API_KEY);
            const response = await fetch(
                `${BASE_URL}/current.json?key=${WEATHER_API_KEY}&q=London&aqi=no`
            );

            const responseText = await response.text();
            console.log('Test API Response:', response.status, responseText);

            return {
                success: response.ok,
                status: response.status,
                data: responseText
            };
        } catch (error) {
            console.error('API Test error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    },

    // Get current weather by coordinates
    getCurrentWeather: async (latitude, longitude) => {
        try {
            console.log('API Key being used:', WEATHER_API_KEY ? 'Present' : 'Missing');
            console.log('Making request to:', `${BASE_URL}/current.json?key=${WEATHER_API_KEY?.substring(0, 8)}...&q=${latitude},${longitude}&aqi=no`);

            const response = await fetch(
                `${BASE_URL}/current.json?key=${WEATHER_API_KEY}&q=${latitude},${longitude}&aqi=no`
            );

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Response:', response.status, errorText);
                throw new Error(`Weather API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            return {
                success: true,
                data
            };
        } catch (error) {
            console.error('Weather service error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    },

    // Get weather forecast (optional for future use)
    getForecast: async (latitude, longitude, days = 3) => {
        try {
            const response = await fetch(
                `${BASE_URL}/forecast.json?key=${WEATHER_API_KEY}&q=${latitude},${longitude}&days=${days}&aqi=no&alerts=no`
            );

            if (!response.ok) {
                throw new Error(`Weather API error: ${response.status}`);
            }

            const data = await response.json();
            return {
                success: true,
                data
            };
        } catch (error) {
            console.error('Weather forecast service error:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
};

import * as Location from 'expo-location';
import { createContext, useContext, useEffect, useState } from 'react';
import { weatherService } from '../services/weatherService';

const LocationContext = createContext({});

export const useLocation = () => {
    const context = useContext(LocationContext);
    if (!context) {
        throw new Error('useLocation must be used within LocationProvider');
    }
    return context;
};

export const LocationProvider = ({ children }) => {
    const [coordinates, setCoordinates] = useState({ latitude: null, longitude: null });
    const [locationInfo, setLocationInfo] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        getCurrentLocation();
    }, []);

    const getCurrentLocation = async () => {
        try {
            setLoading(true);
            console.log('Requesting location permissions...');

            // Request permissions
            let { status } = await Location.requestForegroundPermissionsAsync();
            console.log('Location permission status:', status);

            if (status !== 'granted') {
                console.log('Permission to access location was denied, using fallback');
                // Fallback to a default location (New Delhi)
                await setFallbackLocation();
                return;
            }

            console.log('Getting current position...');
            // Get current location
            let location = await Location.getCurrentPositionAsync({
                accuracy: Location.Accuracy.Balanced,
                timeout: 10000,
            });

            console.log('Got location:', location.coords.latitude, location.coords.longitude);
            const coords = {
                latitude: location.coords.latitude,
                longitude: location.coords.longitude
            };

            setCoordinates(coords);
            await fetchLocationInfo(coords.latitude, coords.longitude);

        } catch (error) {
            console.log('Location error:', error);
            await setFallbackLocation();
        } finally {
            setLoading(false);
        }
    };

    const setFallbackLocation = async () => {
        // Fallback to a default location (New Delhi)
        console.log('Using fallback location: New Delhi');
        const coords = {
            latitude: 28.6139,
            longitude: 77.2090
        };
        setCoordinates(coords);
        await fetchLocationInfo(coords.latitude, coords.longitude);
    };

    const fetchLocationInfo = async (lat, lon) => {
        try {
            const result = await weatherService.getCurrentWeather(lat, lon);
            if (result.success) {
                setLocationInfo({
                    name: result.data.location.name,
                    region: result.data.location.region,
                    country: result.data.location.country,
                    state: result.data.location.region, // Using region as state
                    district: result.data.location.name, // Using name as district approximation
                });
                console.log('Location info set:', result.data.location);
            }
        } catch (error) {
            console.error('Error fetching location info:', error);
        }
    };

    const refreshLocation = async () => {
        await getCurrentLocation();
    };

    const value = {
        coordinates,
        locationInfo,
        loading,
        refreshLocation,
        hasLocation: coordinates.latitude !== null && coordinates.longitude !== null
    };

    return (
        <LocationContext.Provider value={value}>
            {children}
        </LocationContext.Provider>
    );
};

export default LocationContext;
