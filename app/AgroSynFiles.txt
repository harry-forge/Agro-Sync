//////////////
// app/_layout.jsx:
/////////////

import { useFonts } from 'expo-font';
import { Stack, useRouter } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';
import { AuthProvider, useAuth } from "../contexts/AuthContext";
import { LocationProvider } from "../contexts/LocationContext";

// Prevent the splash screen from auto-hiding while we load the fonts
SplashScreen.preventAutoHideAsync();

const RootLayoutWithProvider = () => {
    return(
        <AuthProvider>
            <LocationProvider>
                <MainLayout />
            </LocationProvider>
        </AuthProvider>
    )
}

export default RootLayoutWithProvider;

export function MainLayout() {
    const {setAuth, setUserData} = useAuth();
    const router = useRouter();

    const [fontsLoaded, fontError] = useFonts({
        // --- LOAD ALL YOUR FONTS HERE ---
        'SFNSDisplay-Black': require('../assets/fonts/SFNSDisplay-Black.otf'),
        'SFNSDisplay-Bold': require('../assets/fonts/SFNSDisplay-Bold.otf'),
        'SFNSDisplay-Heavy': require('../assets/fonts/SFNSDisplay-Heavy.otf'),
        'SFNSDisplay-Light': require('../assets/fonts/SFNSDisplay-Light.otf'),
        'SFNSDisplay-Medium': require('../assets/fonts/SFNSDisplay-Medium.otf'),
        'SFNSDisplay-Regular': require('../assets/fonts/SFNSDisplay-Regular.otf'),
        'SFNSDisplay-Semibold': require('../assets/fonts/SFNSDisplay-Semibold.otf'),
        'SFNSDisplay-Thin': require('../assets/fonts/SFNSDisplay-Thin.otf'),
        'SFNSDisplay-Ultralight': require('../assets/fonts/SFNSDisplay-Ultralight.otf'),

        // SFNSText Fonts
        'SFNSText-Bold': require('../assets/fonts/SFNSText-Bold.otf'),
        'SFNSText-BoldItalic': require('../assets/fonts/SFNSText-BoldItalic.otf'),
        'SFNSText-BoldItalicG1': require('../assets/fonts/SFNSText-BoldItalicG1.otf'),
        'SFNSText-BoldItalicG2': require('../assets/fonts/SFNSText-BoldItalicG2.otf'),
        'SFNSText-BoldItalicG3': require('../assets/fonts/SFNSText-BoldItalicG3.otf'),
        'SFNSText-BoldG1': require('../assets/fonts/SFNSText-BoldG1.otf'),
        'SFNSText-BoldG2': require('../assets/fonts/SFNSText-BoldG2.otf'),
        'SFNSText-BoldG3': require('../assets/fonts/SFNSText-BoldG3.otf'),
        'SFNSText-HeavyItalic': require('../assets/fonts/SFNSText-HeavyItalic.otf'),
        'SFNSText-LightItalic': require('../assets/fonts/SFNSText-LightItalic.otf'),
        'SFNSText-Medium': require('../assets/fonts/SFNSText-Medium.otf'),
        'SFNSText-MediumItalic': require('../assets/fonts/SFNSText-MediumItalic.otf'),
        'SFNSText-Regular': require('../assets/fonts/SFNSText-Regular.otf'),
        'SFNSText-RegularG1': require('../assets/fonts/SFNSText-RegularG1.otf'),
        'SFNSText-RegularG2': require('../assets/fonts/SFNSText-RegularG2.otf'),
        'SFNSText-RegularG3': require('../assets/fonts/SFNSText-RegularG3.otf'),
        'SFNSText-RegularItalic': require('../assets/fonts/SFNSText-RegularItalic.otf'),
        'SFNSText-RegularItalicG1': require('../assets/fonts/SFNSText-RegularItalicG1.otf'),
        'SFNSText-RegularItalicG2': require('../assets/fonts/SFNSText-RegularItalicG2.otf'),
        'SFNSText-RegularItalicG3': require('../assets/fonts/SFNSText-RegularItalicG3.otf'),
        'SFNSText-Semibold': require('../assets/fonts/SFNSText-Semibold.otf'),
        'SFNSText-SemiboldItalic': require('../assets/fonts/SFNSText-SemiboldItalic.otf'),
    });

    useEffect(() => {
        if (fontsLoaded || fontError) {
            SplashScreen.hideAsync();
        }
    }, [fontsLoaded, fontError]);

    useEffect(() => {
        if (fontError) {
            console.error(fontError);
        }
    }, [fontError]);

    if (!fontsLoaded && !fontError) {
        return null;
    }

    return (
        <Stack screenOptions={{ headerShown: false }}>
            <Stack.Screen name="(tabs)" />
            <Stack.Screen name="profile" options={{ presentation: 'card' }} />
        </Stack>
    );
}




////////////
// app/(tabs)/_layout.jsx
///////////
import { Ionicons } from "@expo/vector-icons";
import { Tabs, useSegments } from "expo-router";
import { Platform, StyleSheet, View } from "react-native";
import { FieldProvider } from "../../contexts/FieldContext";
import AskAIFab from "../../components/AskAIFab";   // <--- ADDED

const COLORS = {
    primary: '#22C55E',
    primaryDark: '#16A34A',
    background: '#FFFFFF',
    inactive: '#94A3B8',
    activeBackground: '#DCFCE7',
    shadow: '#000000',
    border: '#F1F5F9',
};

const TabBarIcon = ({ name, color, focused }) => {
    return (
        <View style={[
            styles.iconWrapper,
            focused && styles.iconWrapperActive
        ]}>
            <View style={[
                styles.iconContainer,
                focused && styles.iconContainerActive
            ]}>
                <Ionicons
                    name={name}
                    size={focused ? 28 : 26}
                    color={focused ? COLORS.primary : color}
                />
            </View>
            {focused && <View style={styles.activeIndicator} />}
        </View>
    );
};

export default function TabLayout() {
    const segments = useSegments();
    const onHelp = segments.includes("help"); // <--- determines if current screen = help

    return (
        <FieldProvider>
            <>
                <Tabs
                    screenOptions={{
                        headerShown: false,
                        tabBarActiveTintColor: COLORS.primary,
                        tabBarInactiveTintColor: COLORS.inactive,
                        tabBarStyle: {
                            position: 'absolute',
                            bottom: 20,
                            left: 20,
                            right: 20,
                            backgroundColor: COLORS.background,
                            borderRadius: 30,
                            height: 80,
                            paddingBottom: 15,
                            paddingTop: 12,
                            paddingHorizontal: 15,
                            borderTopWidth: 0,
                            borderWidth: 0,
                            marginHorizontal: 15,
                            ...Platform.select({
                                ios: {
                                    shadowColor: COLORS.shadow,
                                    shadowOffset: { width: 0, height: 10 },
                                    shadowOpacity: 0.15,
                                    shadowRadius: 25,
                                },
                                android: {
                                    elevation: 15,
                                },
                            }),
                        },
                        tabBarLabelStyle: {
                            fontSize: 11,
                            fontFamily: 'SFNSText-Bold',
                            fontWeight: '700',
                            letterSpacing: 0.5,
                            marginTop: 8,
                        },
                        tabBarItemStyle: {
                            paddingVertical: 5,
                        },
                        tabBarShowLabel: true,
                        tabBarHideOnKeyboard: true,
                    }}
                >
                    <Tabs.Screen
                        name="home"
                        options={{
                            title: "Home",
                            tabBarIcon: ({ color, focused }) => (
                                <TabBarIcon
                                    name={focused ? "home" : "home-outline"}
                                    color={color}
                                    focused={focused}
                                />
                            ),
                        }}
                    />
                    <Tabs.Screen
                        name="recommendation"
                        options={{
                            title: "Market",
                            tabBarIcon: ({ color, focused }) => (
                                <TabBarIcon
                                    name={focused ? "telescope" : "telescope-outline"}
                                    color={color}
                                    focused={focused}
                                />
                            ),
                        }}
                    />
                    <Tabs.Screen
                        name="fields"
                        options={{
                            title: "Fields",
                            tabBarIcon: ({ color, focused }) => (
                                <TabBarIcon
                                    name={focused ? "leaf" : "leaf-outline"}
                                    color={color}
                                    focused={focused}
                                />
                            ),
                        }}
                    />
                    <Tabs.Screen
                        name="help"
                        options={{
                            title: "Help",
                            tabBarIcon: ({ color, focused }) => (
                                <TabBarIcon
                                    name={focused ? "compass" : "compass-outline"}
                                    color={color}
                                    focused={focused}
                                />
                            ),
                        }}
                    />
                </Tabs>

                {/* FAB SHOWS ON ALL SCREENS EXCEPT HELP */}
                {!onHelp && <AskAIFab />}
            </>
        </FieldProvider>
    );
}

const styles = StyleSheet.create({
    iconWrapper: {
        alignItems: 'center',
        justifyContent: 'center',
    },
    iconWrapperActive: {
        transform: [{ translateY: -3 }],
    },
    iconContainer: {
        width: 66,
        height: 42,
        justifyContent: 'center',
        alignItems: 'center',
        borderRadius: 18,
        backgroundColor: 'transparent',
    },
    iconContainerActive: {
        backgroundColor: COLORS.activeBackground,
        ...Platform.select({
            ios: {
                shadowColor: COLORS.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.2,
                shadowRadius: 12,
            },
            android: {
                elevation: 5,
                marginBottom: 6,
            },
        }),
    },
    activeIndicator: {
        width: 30,
        height: 3,
        backgroundColor: COLORS.primary,
        borderRadius: 2,
        marginTop: 6,
        marginBottom: -14,
        position: 'absolute',
        bottom: -10,
    },
});









//////////////////
// app/(tabs)/fields.jsx  ‚Äî Fields tab UI + glue
/////////////////

import { useEffect, useMemo, useState } from "react";
import { ScrollView, StyleSheet, Text, View, Pressable } from "react-native";
import ScreenWrapper from "../../components/ScreenWrapper";
import { theme } from "../../constants/theme";
import { hp, wp } from "../../helpers/common";
import { iotService } from "../../services/iotService";
import { weatherService } from "../../services/weatherService";
import { predictSoilParams, generateCropDescriptionBoth } from "../../services/geminiService";
import { getCropRecommendation } from "../../services/cropRecommendationService";
import LottieView from "lottie-react-native";
import { useFieldData } from "../../contexts/FieldContext";   // <--- ADDED


export default function Fields() {
    // NEW
    const { setFieldData } = useFieldData();  // <--- ADDED

    const [loading, setLoading] = useState(true);
    const [iot, setIot] = useState(null);
    const [weather, setWeather] = useState(null);
    const [predicted, setPredicted] = useState(null);
    const [recommendation, setRecommendation] = useState(null);
    const [error, setError] = useState("");

    const [englishDesc, setEnglishDesc] = useState(null);
    const [hindiDesc, setHindiDesc] = useState(null);
    const [isHindi, setIsHindi] = useState(false);


    const moisturePct = useMemo(() => {
        if (!iot?.soil && iot?.soil !== 0) return null;
        return Math.max(0, Math.min(100, Math.round((Number(iot.soil) / 4095) * 100)));
    }, [iot?.soil]);

    const temperature = iot?.temperature ?? null;
    const humidity = iot?.humidity ?? null;
    const rainfall = weather?.current?.precip_mm ?? null;

    useEffect(() => {
        (async () => {
            try {
                setLoading(true);

                const iotRes = await iotService.getData();
                if (!iotRes.success) throw new Error(iotRes.error || "IoT fetch failed");
                setIot(iotRes.data);

                const loc = await weatherService.getCachedOrCurrentLocation?.();
                const lat = loc?.latitude ?? 28.6139;
                const lon = loc?.longitude ?? 77.2090;
                const w = await weatherService.getCurrentWeather(lat, lon);
                if (!w.success) throw new Error(w.error || "Weather fetch failed");
                setWeather(w.data);

                const preds = await predictSoilParams({
                    temperature: iotRes.data.temperature,
                    humidity: iotRes.data.humidity,
                    moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                    rainfall: w.data?.current?.precip_mm ?? 0,
                });
                setPredicted(preds);

                const payload = {
                    K: preds.K,
                    N: preds.N,
                    P: preds.P,
                    humidity: iotRes.data.humidity,
                    moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                    pH: preds.pH,
                    rainfall: w.data?.current?.precip_mm ?? 0,
                    temperature: iotRes.data.temperature,
                };
                const rec = await getCropRecommendation(payload);
                setRecommendation(rec);

                const both = await generateCropDescriptionBoth({
                    crop: rec.best_crop,
                    N: preds.N,
                    P: preds.P,
                    K: preds.K,
                    pH: preds.pH,
                    temperature: iotRes.data.temperature,
                    humidity: iotRes.data.humidity,
                    moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                    rainfall: w.data?.current?.precip_mm ?? 0,
                });
                setEnglishDesc(both.english);
                setHindiDesc(both.hindi);


                // =====================
                // UPDATE GLOBAL CONTEXT
                // =====================
                setFieldData({
                    temperature: iotRes.data.temperature,
                    humidity: iotRes.data.humidity,
                    moisture: Math.max(0, Math.min(100, Math.round((Number(iotRes.data.soil) / 4095) * 100))),
                    rainfall: w.data?.current?.precip_mm ?? 0,
                    N: preds.N,
                    P: preds.P,
                    K: preds.K,
                    pH: preds.pH,
                });

            } catch (e) {
                console.log("üí• GEMINI / RECOMMENDER ERROR:", e);
                setError(e.message || JSON.stringify(e));
            } finally {
                setLoading(false);
            }
        })();
    }, []);

    const handleTranslate = () => {
        setIsHindi(!isHindi);
    };


    return (
        <ScreenWrapper bg="white">
            <ScrollView contentContainerStyle={styles.container}>
                <Text style={styles.pageTitle}>Fields</Text>

                {loading ? (
                    <View style={styles.loadingCard}>
                        <LottieView
                            source={require("../../assets/animations/loading.json")}
                            style={styles.loadingAnimation}
                            autoPlay
                            loop
                            speed={1.2}
                        />
                        <Text style={styles.loadingText}>Collecting field data‚Ä¶</Text>
                    </View>
                ) : error ? (
                    <View style={styles.errorCard}>
                        <Text style={styles.errorText}>‚ö†Ô∏è {error}</Text>
                    </View>
                ) : (
                    <>
                        <View style={styles.card}>
                            <Text style={styles.cardTitle}>Current Inputs</Text>

                            <View style={styles.row}>
                                <Item label="Temperature" value={temperature ?? "‚Äî"} unit="¬∞C" source="IoT" />
                                <Item label="Humidity" value={humidity ?? "‚Äî"} unit="%" source="IoT" />
                            </View>

                            <View style={styles.row}>
                                <Item label="Moisture" value={moisturePct ?? "‚Äî"} unit="%" source="IoT" />
                                <Item label="Rainfall" value={rainfall ?? 0} unit="mm" source="Weather" />
                            </View>

                            <View style={styles.separator} />

                            <View style={styles.row}>
                                <Item label="Nitrogen (N)" value={predicted?.N ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Phosphorus (P)" value={predicted?.P ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                            </View>
                            <View style={styles.row}>
                                <Item label="Potassium (K)" value={predicted?.K ?? "‚Äî"} unit="kg/ha" source="Predicted" />
                                <Item label="Soil pH" value={predicted?.pH ?? "‚Äî"} unit="" source="Predicted" />
                            </View>
                        </View>

                        <View style={styles.card}>
                            <Text style={styles.cardTitle}>Today‚Äôs Recommendation</Text>
                            {recommendation ? (
                                <View style={{ gap: hp(1) }}>
                                    <Text style={styles.recoCrop}>{recommendation.best_crop}</Text>
                                    <Text style={styles.recoProb}>Confidence: {Number(recommendation.probability).toFixed(2)}</Text>

                                    {englishDesc && (
                                        <>
                                            <View style={styles.descBox}>
                                                <Text style={styles.descPlaceholder}>
                                                    {isHindi ? hindiDesc : englishDesc}
                                                </Text>
                                            </View>

                                            <Pressable
                                                onPress={handleTranslate}
                                                style={{
                                                    backgroundColor: theme.colors.primary,
                                                    paddingVertical: hp(1.2),
                                                    borderRadius: 8,
                                                    alignItems: "center",
                                                }}
                                            >
                                                <Text style={{ color: "white", fontFamily: "SFNSText-Medium" }}>
                                                    {isHindi ? "Show English" : "Translate to Hindi"}
                                                </Text>
                                            </Pressable>
                                        </>
                                    )}
                                </View>
                            ) : (
                                <Text style={styles.descPlaceholder}>No recommendation available.</Text>
                            )}
                        </View>
                    </>
                )}
            </ScrollView>
        </ScreenWrapper>
    );
}

function Item({ label, value, unit, source }) {
    return (
        <View style={styles.item}>
            <Text style={styles.itemLabel}>{label}</Text>
            <Text style={styles.itemValue}>
                {value}{unit ? ` ${unit}` : ""} <Text style={styles.sourceTag}>({source})</Text>
            </Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        paddingHorizontal: wp(5),
        paddingTop: hp(2),
        paddingBottom: hp(12),
        gap: hp(2),
    },
    pageTitle: {
        fontSize: hp(2.4),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    card: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
        shadowColor: "rgb(2,57,18)",
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.08,
        shadowRadius: 12,
        elevation: 6,
        gap: hp(1.2),
    },
    cardTitle: {
        fontSize: hp(2),
        fontFamily: "SFNSDisplay-Bold",
        color: theme.colors.textDark,
    },
    row: {
        flexDirection: "row",
        gap: wp(4),
    },
    item: {
        flex: 1,
        gap: hp(0.5),
    },
    itemLabel: {
        fontSize: hp(1.5),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    itemValue: {
        fontSize: hp(2.1),
        color: theme.colors.textDark,
        fontFamily: "SFNSDisplay-Bold",
    },
    sourceTag: {
        fontSize: hp(1.5),
        color: theme.colors.primary,
        fontFamily: "SFNSText-Medium",
    },
    separator: {
        height: 1,
        backgroundColor: "rgba(0,0,0,0.06)",
        marginVertical: hp(0.5),
    },
    loadingCard: {
        backgroundColor: "#fff",
        borderRadius: 16,
        padding: wp(6),
        alignItems: "center",
        borderWidth: 1,
        borderColor: "rgba(80,200,120,0.12)",
    },
    loadingAnimation: { width: wp(20), height: wp(20) },
    loadingText: {
        marginTop: hp(1),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
    errorCard: {
        backgroundColor: "#fff5f5",
        borderRadius: 16,
        padding: wp(4),
        borderWidth: 1,
        borderColor: "#ffd6d6",
    },
    errorText: {
        color: "#c0392b",
        fontFamily: "SFNSDisplay-Bold",
    },
    recoCrop: {
        fontSize: hp(2.2),
        fontFamily: "SFNSDisplay-Heavy",
        color: theme.colors.primary,
    },
    recoProb: {
        fontSize: hp(1.8),
        fontFamily: "SFNSText-Medium",
        color: theme.colors.textDark,
    },
    descBox: {
        borderWidth: 1,
        borderColor: "rgba(0,0,0,0.08)",
        borderRadius: 12,
        padding: wp(3),
        backgroundColor: "#fafafa",
    },
    descPlaceholder: {
        fontSize: hp(1.6),
        color: theme.colors.textLight,
        fontFamily: "SFNSText-Regular",
    },
});


/////////////
// contexts/FieldContext.js
////////////////

import { createContext, useContext, useState } from "react";

const FieldContext = createContext(null);

export function FieldProvider({ children }) {
    const [fieldData, setFieldData] = useState({
        temperature: null,
        humidity: null,
        moisture: null,
        rainfall: null,
        N: null,
        P: null,
        K: null,
        pH: null,
    });

    return (
        <FieldContext.Provider value={{ fieldData, setFieldData }}>
            {children}
        </FieldContext.Provider>
    );
}

export function useFieldData() {
    return useContext(FieldContext);
}



////////////////////
// contexts/LocationContext.js
////////////////////

import * as Location from 'expo-location';
import { createContext, useContext, useEffect, useState } from 'react';
import { weatherService } from '../services/weatherService';

const LocationContext = createContext({});

export const useLocation = () => {
    const context = useContext(LocationContext);
    if (!context) {
        throw new Error('useLocation must be used within LocationProvider');
    }
    return context;
};

export const LocationProvider = ({ children }) => {
    const [coordinates, setCoordinates] = useState({ latitude: null, longitude: null });
    const [locationInfo, setLocationInfo] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        getCurrentLocation();
    }, []);

    const getCurrentLocation = async () => {
        try {
            setLoading(true);
            console.log('Requesting location permissions...');

            // Request permissions
            let { status } = await Location.requestForegroundPermissionsAsync();
            console.log('Location permission status:', status);

            if (status !== 'granted') {
                console.log('Permission to access location was denied, using fallback');
                // Fallback to a default location (New Delhi)
                await setFallbackLocation();
                return;
            }

            console.log('Getting current position...');
            // Get current location
            let location = await Location.getCurrentPositionAsync({
                accuracy: Location.Accuracy.Balanced,
                timeout: 10000,
            });

            console.log('Got location:', location.coords.latitude, location.coords.longitude);
            const coords = {
                latitude: location.coords.latitude,
                longitude: location.coords.longitude
            };

            setCoordinates(coords);
            await fetchLocationInfo(coords.latitude, coords.longitude);

        } catch (error) {
            console.log('Location error:', error);
            await setFallbackLocation();
        } finally {
            setLoading(false);
        }
    };

    const setFallbackLocation = async () => {
        // Fallback to a default location (New Delhi)
        console.log('Using fallback location: New Delhi');
        const coords = {
            latitude: 28.6139,
            longitude: 77.2090
        };
        setCoordinates(coords);
        await fetchLocationInfo(coords.latitude, coords.longitude);
    };

    const fetchLocationInfo = async (lat, lon) => {
        try {
            const result = await weatherService.getCurrentWeather(lat, lon);
            if (result.success) {
                setLocationInfo({
                    name: result.data.location.name,
                    region: result.data.location.region,
                    country: result.data.location.country,
                    state: result.data.location.region, // Using region as state
                    district: result.data.location.name, // Using name as district approximation
                });
                console.log('Location info set:', result.data.location);
            }
        } catch (error) {
            console.error('Error fetching location info:', error);
        }
    };

    const refreshLocation = async () => {
        await getCurrentLocation();
    };

    const value = {
        coordinates,
        locationInfo,
        loading,
        refreshLocation,
        hasLocation: coordinates.latitude !== null && coordinates.longitude !== null
    };

    return (
        <LocationContext.Provider value={value}>
            {children}
        </LocationContext.Provider>
    );
};

export default LocationContext;



///////////////////
//contexts/AuthContext.js
////////////////////

import { createContext, useContext, useEffect, useState } from "react";
import { supabase } from "../lib/supabase";
import { getUserData } from "../services/userService";

const AuthContext = createContext();

export const AuthProvider = ({children}) => {
    const [user, setUser] = useState(null);
    const [isInitialized, setIsInitialized] = useState(false);

    const setAuth = authUser=>{
        setUser(authUser);
    }

    const setUserData = userData => {
        setUser({...userData});
    }

    const logout = async () => {
        try {
            const {error} = await supabase.auth.signOut();
            if(error) {
                console.log('Logout error:', error);
                return {success: false, error: error.message};
            }
            return {success: true};
        } catch (error) {
            console.log('Logout error:', error);
            return {success: false, error: 'Failed to logout'};
        }
    }

    // Handle authentication in the context instead of the layout
    useEffect(() => {
        let isMounted = true;

        const { data: authListener } = supabase.auth.onAuthStateChange(async (_event, session)=> {
            if (!isMounted) return;

            // Only log significant events (temporarily disabled to stop spam)
            // if (_event === 'SIGNED_IN' || _event === 'SIGNED_OUT' || (_event === 'INITIAL_SESSION' && !isInitialized)) {
            //     console.log('Auth Event:', _event, 'Session User:', session?.user?.id);
            // }

            if (session && session.user) {
                setAuth(session?.user);
                // Get user data
                try {
                    const res = await getUserData(session?.user?.id);
                    if (res.success) {
                        setUserData({...session?.user, ...res.data});
                    }
                } catch (error) {
                    console.log('Error getting user data:', error);
                }
            } else {
                setAuth(null);
            }

            if (!isInitialized) {
                setIsInitialized(true);
            }
        });

        return () => {
            isMounted = false;
            if (authListener && authListener.subscription) {
                authListener.subscription.unsubscribe();
            }
        }
    }, []);

    return (
        <AuthContext.Provider value={{user, setAuth, setUserData, logout, isInitialized}}>
            {children}
        </AuthContext.Provider>
    )
}

export const useAuth = () => useContext(AuthContext);


////////////////////
// services/geminiService.js
////////////////////

// =============================
// /services/geminiService.js
// =============================

const GEMINI_API_KEY = process.env.EXPO_PUBLIC_GEMINI_API_KEY;
const GEMINI_ENDPOINT =
    "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent";


function buildPrompt({ temperature, humidity, moisture, rainfall }) {
    return `You are an agronomy assistant. Given current field conditions, estimate soil macronutrients and pH for use in a crop recommendation model.

Return ONLY a strict minified JSON object with numeric values (no comments, no text around it), like:
{"N":80,"P":35,"K":40,"pH":6.5}

Constraints:
- N, P, K are in kg/ha, integers 0-300
- pH is 3.5 - 9.5 (one decimal)
- If information is insufficient, infer a reasonable value from typical Indian loamy soils in Kharif season.

Conditions:
- temperature_C: ${temperature}
- humidity_pct: ${humidity}
- soil_moisture_pct: ${moisture}
- rainfall_mm: ${rainfall}
`;
}

function extractJsonFromText(text) {
    try {
        // If it's already pure JSON
        return JSON.parse(text);
    } catch (_) {
        // Try to locate the first {...} block
        const start = text.indexOf("{");
        const end = text.lastIndexOf("}");
        if (start !== -1 && end !== -1 && end > start) {
            const jsonSlice = text.slice(start, end + 1);
            return JSON.parse(jsonSlice);
        }
        throw new Error("Gemini response did not contain valid JSON.");
    }
}

export async function predictSoilParams({ temperature, humidity, moisture, rainfall }) {
    if (!GEMINI_API_KEY) {
        throw new Error("Missing EXPO_PUBLIC_GEMINI_API_KEY");
    }

    const body = {
        contents: [
            {
                role: "user",
                parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
            },
        ],
        generationConfig: {
            temperature: 0.4,
            maxOutputTokens: 128,
        },
    };

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [
                {
                    role: "user",
                    parts: [{ text: buildPrompt({ temperature, humidity, moisture, rainfall }) }],
                },
            ],
        }),
    });


    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const text = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
    const parsed = extractJsonFromText(text);

    const N = Math.max(0, Math.min(300, Math.round(Number(parsed.N))));
    const P = Math.max(0, Math.min(300, Math.round(Number(parsed.P))));
    const K = Math.max(0, Math.min(300, Math.round(Number(parsed.K))));
    const pH = Math.max(3.5, Math.min(9.5, Number(parsed.pH)));

    if ([N, P, K].some((v) => Number.isNaN(v)) || Number.isNaN(pH)) {
        throw new Error("Gemini returned invalid numbers");
    }

    return { N, P, K, pH: Number(pH.toFixed(1)) };
}

// --- Helpers: robust JSON extraction/parsing from LLM text ---
// Finds the first balanced {...} JSON object (ignores braces inside quotes)
function findFirstJsonObject(s) {
    if (!s) return null;

    // strip common wrappers
    let t = s.trim().replace(/```json/gi, "").replace(/```/g, "");
    // also strip any preface before the first '{'
    const firstBrace = t.indexOf("{");
    if (firstBrace > 0) t = t.slice(firstBrace);

    let depth = 0;
    let inString = false;
    let escape = false;

    for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        if (inString) {
            if (escape) {
                escape = false;
            } else if (ch === "\\") {
                escape = true;
            } else if (ch === "\"") {
                inString = false;
            }
            continue;
        }

        if (ch === "\"") {
            inString = true;
            continue;
        }
        if (ch === "{") {
            depth++;
            continue;
        }
        if (ch === "}") {
            depth--;
            if (depth === 0) {
                // slice inclusive of this closing brace
                return t.slice(0, i + 1);
            }
            continue;
        }
    }
    return null; // not found
}

function safeParseGeminiJson(text) {
    const jsonSlice = findFirstJsonObject(text);
    if (!jsonSlice) throw new Error("No JSON object found in Gemini response.");
    // Clean any stray leading commas/colons/newlines
    const clean = jsonSlice.replace(/^[,:\\s]+/, "");
    return JSON.parse(clean);
}

// =====================
// ONE-CALL: English + Hindi description
// =====================
export async function generateCropDescriptionBoth({
                                                      crop, N, P, K, pH, temperature, humidity, moisture, rainfall
                                                  }) {
    const prompt = `
You are an agriculture advisor.
Generate TWO versions of a very short advice (max 3 lines) for a farmer based on this crop and field data.

crop=${crop}
N=${N}, P=${P}, K=${K}, pH=${pH}
temperature=${temperature}C, humidity=${humidity}%, moisture=${moisture}%, rainfall=${rainfall}mm

Return EXACTLY and ONLY this JSON (no extra words, no backticks):
{"english":"<simple english, farmer-friendly>", "hindi":"<simple Hindi, farmer-friendly>"}
`;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini API error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    const raw = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

    try {
        const obj = safeParseGeminiJson(raw);
        // Minimal sanity
        if (!obj || typeof obj !== "object") throw new Error("Parsed result is not an object");
        if (typeof obj.english !== "string" || typeof obj.hindi !== "string") {
            throw new Error("Parsed JSON missing 'english' or 'hindi' strings");
        }
        return obj; // { english, hindi }
    } catch (e) {
        // Log raw to console to debug quickly, but don't crash the app silently
        console.log("üîé Gemini raw description text =>", raw);
        throw e;
    }
}


// =====================
// HELP: Ask AI with context
// =====================
export async function helpAnswer({ question, context }) {
    if (!question || !question.trim()) return "";

    const prompt = `
You are an agriculture advisor inside AgroSync app.
This is the current field context:

Temperature: ${context.temperature}¬∞C
Humidity: ${context.humidity}%
Moisture: ${context.moisture}%
Rainfall: ${context.rainfall}mm
N: ${context.N}
P: ${context.P}
K: ${context.K}
pH: ${context.pH}

User question:
${question.trim()}

Answer in 3-5 short lines, simple farmer-friendly English.
Do not use codeblocks or markdown.
  `;

    const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ role: "user", parts: [{ text: prompt }] }],
        }),
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`Gemini Help error: ${res.status} ${errText}`);
    }

    const data = await res.json();
    return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
}



//
// // =====================
// // translate to Hindi
// // =====================
// export async function translateToHindi(text) {
//     const prompt = `Translate this to simple Hindi suitable for farmers:\n${text}`;
//
//     const res = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
//         method:"POST",
//         headers:{ "Content-Type":"application/json" },
//         body:JSON.stringify({
//             contents:[{role:"user", parts:[{text:prompt}]}]
//         })
//     });
//
//     const data = await res.json();
//     return data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
// }

////////////////////
// services/iotService.js
////////////////////

// IoT Device Service
class IoTService {
    constructor() {
        this.baseUrl = 'https://iot-device-backend-dguk.onrender.com';
        // this.baseUrl = 'https://mocki.io/v1/1588969d-1261-4a66-a509-2ce3bb95bd8a';
    }

    async getData() {
        try {
            console.log('Fetching IoT data...');
            const response = await fetch(`${this.baseUrl}/data`, {
            //     const response = await fetch(`${this.baseUrl}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('IoT Data Response:', data);

            return {
                success: true,
                data: data
            };
        } catch (error) {
            console.error('IoT Service Error:', error);
            return {
                success: false,
                error: error.message || 'Failed to fetch IoT data'
            };
        }
    }

    // Helper methods to format data
    formatTemperature(temp) {
        return `${Math.round(temp)}¬∞C`;
    }

    formatHumidity(humidity) {
        return `${Math.round(humidity)}%`;
    }

    formatSoilMoisture(soil) {
        // Convert soil sensor reading to percentage (0-4095 range)
        const percentage = Math.round((soil / 4095) * 100);
        return `${percentage}%`;
    }

    formatLightLevel(light) {
        return light || 'Unknown';
    }

    formatRainLevel(rain) {
        // Rain sensor: higher values typically mean less rain
        if (rain > 3500) return 'No Rain';
        if (rain > 2500) return 'Light Rain';
        if (rain > 1500) return 'Moderate Rain';
        return 'Heavy Rain';
    }

    // Get sensor status colors
    getTemperatureStatus(temp) {
        if (temp < 10) return { status: 'Cold', color: '#64B5F6' };
        if (temp < 25) return { status: 'Optimal', color: '#4CAF50' };
        if (temp < 35) return { status: 'Warm', color: '#FF9800' };
        return { status: 'Hot', color: '#F44336' };
    }

    getHumidityStatus(humidity) {
        if (humidity < 30) return { status: 'Low', color: '#FF9800' };
        if (humidity < 70) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'High', color: '#2196F3' };
    }

    getSoilMoistureStatus(soil) {
        const percentage = (soil / 4095) * 100;
        if (percentage < 20) return { status: 'Dry', color: '#F44336' };
        if (percentage < 60) return { status: 'Optimal', color: '#4CAF50' };
        return { status: 'Wet', color: '#2196F3' };
    }

    getLightStatus(light) {
        const status = light?.toLowerCase() || 'unknown';
        switch (status) {
            case 'bright':
                return { status: 'Bright', color: '#FFD54F' };
            case 'moderate':
                return { status: 'Moderate', color: '#FFA726' };
            case 'dark':
                return { status: 'Dark', color: '#90A4AE' };
            default:
                return { status: 'Unknown', color: '#BDBDBD' };
        }
    }

    getRainStatus(rain) {
        if (rain > 3500) return { status: 'Clear', color: '#4CAF50' };
        if (rain > 2500) return { status: 'Light Rain', color: '#2196F3' };
        if (rain > 1500) return { status: 'Moderate Rain', color: '#FF9800' };
        return { status: 'Heavy Rain', color: '#F44336' };
    }
}

export const iotService = new IoTService();




// ============================================
// /services/cropRecommendationService.js
// ============================================

const RECOM_BASE = "https://crop-recommender-engine.onrender.com";

export async function getCropRecommendation(payload) {
    const res = await fetch(`${RECOM_BASE}/predict`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
    });
    if (!res.ok) {
        const err = await res.text();
        throw new Error(`Recommender error: ${res.status} ${err}`);
    }
    return res.json(); // { best_crop, probability }
}



